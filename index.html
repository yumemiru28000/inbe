<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Invader (Firebase RTDB) - Single File</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0e14; color:#e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { padding: 10px 12px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #1f2a3a; }
    header b { font-weight: 700; }
    #statusLine { margin-left:auto; color:#a8b3c7; }

    #main { display:grid; grid-template-columns: 360px 1fr; min-height:0; }
    #left { border-right:1px solid #1f2a3a; padding:12px; overflow:auto; }
    #right { min-height:0; display:flex; flex-direction:column; }
    #canvasWrap { flex: 1; min-height: 0; display:flex; position:relative; }
    canvas { width: 100%; height: 100%; display:block; background: #05070b; }

    .card { border:1px solid #1f2a3a; border-radius:10px; padding:10px; margin-bottom:10px; background:#0e1420; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { background:#2b69ff; color:white; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.secondary { background:#223047; }
    button.danger { background:#b42318; }
    button[disabled] { opacity:.45; cursor:not-allowed; }
    input { width: 100%; box-sizing:border-box; padding:8px 10px; border-radius:8px; border:1px solid #26344a; background:#0b1220; color:#e8eefc; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#a8b3c7; }
    .tag { padding:2px 6px; border-radius: 999px; border:1px solid #1f2a3a; background:#0b1220; color:#a8b3c7; font-size:12px; }

    body.playing #main { grid-template-columns: 0px 1fr; }
    body.playing #left { display:none; }
    body.playing #rightTopBar { display:none; }

    #hud {
      position:absolute; left:10px; top:10px;
      background: rgba(10,14,22,.72);
      border:1px solid #1f2a3a;
      padding:8px 10px;
      border-radius:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:#e8eefc;
      min-width: 260px;
    }

    #ann { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.60); }
    #ann .card { width:min(560px, 92vw); }
    #modal { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.60); }
    #modal .card { width:min(560px, 92vw); }
    #modal .row { justify-content:flex-end; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <b>Invader</b>
      <small class="mono" id="me"></small>
      <span class="tag" id="roleTag">role:-</span>
      <div id="statusLine"></div>
    </header>

    <div id="main">
      <div id="left">
        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">名前（最初に必須）</div>
          <input id="nameInput" placeholder="表示名" maxlength="20" />
          <div class="row" style="margin-top:8px;">
            <button id="saveNameBtn">保存</button>
          </div>
          <div style="margin-top:6px; color:#a8b3c7;" id="nameHint"></div>
        </div>

        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">プレイ</div>
          <div class="row">
            <button id="soloBtn">ソロ</button>
            <button id="multiBtn">マルチ</button>
            <button id="watchBtn" class="secondary">観戦（感染）</button>
          </div>
          <div style="margin-top:8px; color:#a8b3c7;" id="playHint"></div>
        </div>

        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">ランキング（上位）</div>
          <div id="leaderboard"></div>
        </div>

        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">現在のセッション</div>
          <pre id="sessionDebug" style="white-space:pre-wrap; margin:0; color:#a8b3c7;"></pre>
        </div>
      </div>

      <div id="right">
        <div id="rightTopBar" style="padding:10px 12px; border-bottom:1px solid #1f2a3a;">
          <div class="row">
            <div><b id="screenTitle">ロビー</b></div>
            <div id="screenSub" style="color:#a8b3c7;"></div>
            <div style="margin-left:auto" class="row">
              <button id="readyBtn" class="secondary" style="display:none;">準備完了</button>
              <button id="retireBtn" class="danger" style="display:none;">ゲームリアタイア</button>
              <button id="leaveBtn" class="danger" style="display:none;">離脱</button>
            </div>
          </div>
        </div>

        <div id="canvasWrap">
          <canvas id="game"></canvas>

          <div id="hud" style="display:none;">
            <div id="hudLine1"></div>
            <div id="hudLine2" style="margin-top:4px;"></div>
            <div id="hudLine3" style="margin-top:4px; color:#a8b3c7;"></div>
          </div>

          <div id="ann">
            <div class="card">
              <div style="font-weight:800; margin-bottom:6px;" id="annTitle"></div>
              <div style="color:#a8b3c7;" id="annBody"></div>
            </div>
          </div>

          <div id="modal">
            <div class="card">
              <div style="font-weight:800; margin-bottom:6px;" id="modalTitle"></div>
              <div style="color:#a8b3c7; margin-bottom:10px;" id="modalBody"></div>
              <div class="row">
                <button id="modalNo" class="secondary">いいえ</button>
                <button id="modalYes">はい</button>
              </div>
            </div>
          </div>

        </div>

      </div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getDatabase, ref, onValue, get, set, update, remove, runTransaction, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
    authDomain: "suisougaku-bdcc0.firebaseapp.com",
    databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com",
    projectId: "suisougaku-bdcc0",
    storageBucket: "suisougaku-bdcc0.firebasestorage.app",
    messagingSenderId: "636001978886",
    appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
    measurementId: "G-Y04PFJ9BQ6"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);
  const auth = getAuth(app);

  const PATHS = {
    presence: (uid) => `presence/${uid}`,
    names: (uid) => `lobby/names/${uid}`,
    leaderboardTop: `leaderboard/top`,
    sessionCurrent: `session/current`,
    sessionGame: `session/current/game`,
    sessionReady: (uid) => `session/current/ready/${uid}`,
    sessionRecruitingJoiner: `session/current/recruiting/joinerUid`,
    sessionInputs: (uid) => `session/current/inputs/${uid}`,
    sessionClientState: (uid) => `session/current/clientState/${uid}`,
    submissions: (sid) => `submissions/${sid}`
  };

  const $ = (q) => document.querySelector(q);
  const ui = {
    me: $("#me"),
    roleTag: $("#roleTag"),
    statusLine: $("#statusLine"),
    playHint: $("#playHint"),
    sessionDebug: $("#sessionDebug"),
    leaderboard: $("#leaderboard"),
    nameInput: $("#nameInput"),
    saveNameBtn: $("#saveNameBtn"),
    nameHint: $("#nameHint"),
    soloBtn: $("#soloBtn"),
    multiBtn: $("#multiBtn"),
    watchBtn: $("#watchBtn"),
    readyBtn: $("#readyBtn"),
    retireBtn: $("#retireBtn"),
    leaveBtn: $("#leaveBtn"),
    screenTitle: $("#screenTitle"),
    screenSub: $("#screenSub"),
    canvas: $("#game"),
    hud: $("#hud"),
    hudLine1: $("#hudLine1"),
    hudLine2: $("#hudLine2"),
    hudLine3: $("#hudLine3"),
    ann: $("#ann"),
    annTitle: $("#annTitle"),
    annBody: $("#annBody"),
    modal: $("#modal"),
    modalTitle: $("#modalTitle"),
    modalBody: $("#modalBody"),
    modalYes: $("#modalYes"),
    modalNo: $("#modalNo"),
  };

  const showAnn = (title, body) => {
    ui.annTitle.textContent = title;
    ui.annBody.textContent = body;
    ui.ann.style.display = "flex";
  };
  const hideAnn = () => ui.ann.style.display = "none";

  function showModal(title, body) {
    ui.modalTitle.textContent = title;
    ui.modalBody.textContent = body;
    ui.modal.style.display = "flex";
  }
  function hideModal() { ui.modal.style.display = "none"; }
  function modalAsk(title, body) {
    return new Promise((resolve) => {
      showModal(title, body);
      const yes = () => { cleanup(); resolve(true); };
      const no = () => { cleanup(); resolve(false); };
      const cleanup = () => {
        ui.modalYes.removeEventListener("click", yes);
        ui.modalNo.removeEventListener("click", no);
        hideModal();
      };
      ui.modalYes.addEventListener("click", yes);
      ui.modalNo.addEventListener("click", no);
    });
  }

  function uuidShort() { return Math.random().toString(16).slice(2, 10); }
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // ---------- Presence helpers ----------
  async function isOnline(uid) {
    if (!uid) return false;
    const s = await get(ref(db, PATHS.presence(uid)));
    const v = s.val();
    return !!v?.online;
  }

  // Choose a "leader" to cleanup when host is gone (simple & deterministic: smallest uid string)
  function chooseLeaderUid(session) {
    const ids = [session?.hostUid, session?.p1Uid, session?.p2Uid].filter(Boolean);
    if (!ids.length) return null;
    ids.sort();
    return ids[0];
  }

  // ---------- Name / leaderboard ----------
  async function getMyName(uid) {
    const snap = await get(ref(db, PATHS.names(uid)));
    const v = snap.val();
    return (typeof v === "string" && v.trim()) ? v.trim() : "";
  }

  function bindLeaderboard() {
    onValue(ref(db, PATHS.leaderboardTop), (snap) => {
      const data = snap.val() || [];
      ui.leaderboard.innerHTML = "";
      if (!Array.isArray(data) || data.length === 0) {
        ui.leaderboard.textContent = "まだ記録がありません";
        return;
      }
      const ol = document.createElement("ol");
      ol.style.margin = "0 0 0 18px";
      for (const row of data) {
        const li = document.createElement("li");
        li.textContent = `${row.name ?? "?"} - ${row.score ?? 0}`;
        ol.appendChild(li);
      }
      ui.leaderboard.appendChild(ol);
    });
  }

  function bindName(uid) {
    const nameRef = ref(db, PATHS.names(uid));
    onValue(nameRef, (snap) => {
      const v = snap.val();
      if (typeof v === "string") ui.nameInput.value = v;
    });
    ui.saveNameBtn.onclick = async () => {
      const v = ui.nameInput.value.trim().slice(0, 20);
      await set(nameRef, v || "no-name");
      ui.nameHint.textContent = `保存済み: ${(v || "no-name")}`;
    };
  }

  // ---------- ClientState ----------
  const setClientState = (uid, st) => set(ref(db, PATHS.sessionClientState(uid)), st);

  // ---------- Canvas / draw ----------
  const ctx = ui.canvas.getContext("2d");
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = ui.canvas.getBoundingClientRect();
    ui.canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    ui.canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function toScreen(xNorm, yNorm) {
    const w = ui.canvas.getBoundingClientRect().width;
    const h = ui.canvas.getBoundingClientRect().height;
    return { x: xNorm * w, y: yNorm * h };
  }

  function drawIdle(text) {
    resizeCanvas();
    ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
    ctx.fillStyle = "#9fb0cc";
    ctx.font = "16px system-ui";
    ctx.fillText(text, 16, 28);
    ctx.fillText("プレイ中ならここに位置/敵/弾/スコアが表示されます", 16, 52);
    ui.hud.style.display = "none";
  }

  function drawBossBar(boss) {
    if (!boss || !boss.alive) return;
    const w = ui.canvas.getBoundingClientRect().width;
    const barW = Math.min(520, w - 24);
    const x = (w - barW) / 2;
    const y = 12;
    const h = 14;

    const ratio = boss.hpMax > 0 ? Math.max(0, boss.hp / boss.hpMax) : 0;

    ctx.fillStyle = "rgba(10,14,22,.72)";
    ctx.fillRect(x - 6, y - 6, barW + 12, h + 12);
    ctx.strokeStyle = "#1f2a3a";
    ctx.strokeRect(x - 6, y - 6, barW + 12, h + 12);

    ctx.fillStyle = "#3a0b0b";
    ctx.fillRect(x, y, barW, h);
    ctx.fillStyle = boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
    ctx.fillRect(x, y, barW * ratio, h);

    ctx.fillStyle = "#e8eefc";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const shield = boss.shieldLeft > 0 ? ` SHIELD:${boss.shieldLeft.toFixed(1)}s` : "";
    ctx.fillText(`BOSS HP ${boss.hp}/${boss.hpMax}  PHASE:${boss.phase}${shield}`, x + 6, y + 11);
  }

  function drawState(g, myUid) {
    resizeCanvas();
    ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
    ui.hud.style.display = "";

    const my = (g.players || []).find(p => p.uid === myUid);
    if (my) {
      const cd = my.shootCooldown ?? 0;
      const can = cd <= 0.001;
      const colorLabel = my.color === "red" ? "RED" : "BLUE";
      ui.hudLine1.textContent = `YOU: ${colorLabel} | SCORE: ${my.score} | WAVE: ${g.wave}`;
      ui.hudLine2.textContent = can ? "発射可能" : `クールダウン: ${cd.toFixed(2)}s`;
      ui.hudLine3.textContent = `A/D移動 Space発射 | 生存: ${my.alive ? "YES" : "NO"}`;
    } else {
      ui.hudLine1.textContent = `WAVE: ${g.wave} elapsed:${g.elapsed ?? "?"}`;
      ui.hudLine2.textContent = "";
      ui.hudLine3.textContent = "";
    }

    drawBossBar(g.boss);

    for (const e of (g.enemies || [])) {
      const s = toScreen(e.x, e.y);
      ctx.fillStyle =
        e.type === "A" ? "#ffd166" :
        e.type === "B" ? "#ff9f1c" :
        e.type === "C" ? "#7bdff2" :
        e.type === "E" ? "#b8f2a6" : "#ffd166";
      ctx.fillRect(s.x - 8, s.y - 8, 16, 16);
    }

    for (const h of (g.hazards || [])) {
      const s = toScreen(h.x, h.y);
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
      ctx.fill();
    }

    if (g.boss && g.boss.alive) {
      const s = toScreen(g.boss.x, g.boss.y);
      ctx.fillStyle = g.boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
      ctx.fillRect(s.x - 26, s.y - 14, 52, 28);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(s.x - 26, s.y - 14, 52, 28);
    }

    for (const p of (g.players || [])) {
      const s = toScreen(p.x, p.y);
      const col = p.color === "red" ? "#ff3b3b" : "#2b78ff";
      ctx.fillStyle = col;
      ctx.fillRect(s.x - 12, s.y - 7, 24, 14);
      if (p.uid === myUid) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x - 14, s.y - 9, 28, 18);
      }
    }

    ctx.fillStyle = "#e8eefc";
    for (const b of (g.playerBullets || [])) {
      const s = toScreen(b.x, b.y);
      ctx.fillRect(s.x - 2, s.y - 8, 4, 16);
    }

    for (const b of (g.enemyBullets || [])) {
      const s = toScreen(b.x, b.y);
      const col =
        b.type === "C_HOMING" ? "#7bdff2" :
        (b.type || "").includes("SNIPE") ? "#ffffff" :
        (b.type || "").includes("WAVE") ? "#b4f8c8" :
        (b.type || "").includes("SPLIT") ? "#ffd6ff" :
        "#ffccff";
      ctx.fillStyle = col;
      ctx.fillRect(s.x - 3, s.y - 3, 6, 6);
    }
  }

  // ---------- Input sender + idle tracking ----------
  function bindInputSender(uid) {
    const keys = { left:false, right:false, shoot:false };
    let playing = false;

    onValue(ref(db, PATHS.sessionCurrent), (snap) => {
      const s = snap.val();
      playing = s?.state === "playing" && (s?.p1Uid === uid || s?.p2Uid === uid);
    });

    window.addEventListener("keydown", (e) => {
      if (e.code === "KeyA") keys.left = true;
      if (e.code === "KeyD") keys.right = true;
      if (e.code === "Space") { keys.shoot = true; e.preventDefault(); }
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "KeyA") keys.left = false;
      if (e.code === "KeyD") keys.right = false;
      if (e.code === "Space") { keys.shoot = false; e.preventDefault(); }
    });

    setInterval(() => {
      if (!playing) return;
      // lastInputAt を入れる（ホストが60秒無操作判定に使う）
      set(ref(db, PATHS.sessionInputs(uid)), { ...keys, t: Date.now() });
    }, 50);
  }

  // ---------- Game Sim (host) ----------
  const WAVE_DUR = [30, 40, 90, 140];
  const SHOOT_CD = 3.0;
  const SCORE = { A: 60, B: 120, C: 200, D: 0, E: 300, BOSS_HIT: 10, BOSS_KILL: 5000 };

  const ENEMY = {
    A: { firePerSec: 0.12, bulletSpeed: 0.28, moveSpeed: 0.06 },
    B: { firePerSec: 0.18, bulletSpeed: 0.32, moveSpeed: 0.09 },
    C: { firePerSec: 0.14, bulletSpeed: 0.26, moveSpeed: 0.06, homingTime: 0.7, turnRate: 2.2 },
    E: { firePerSec: 0.45, bulletSpeed: 0.36 },
    D: { fallSpeed: 0.10 }
  };
  const BOSS = {
    hpMax: 40,
    x: 0.5,
    y: 0.16,
    baseBulletSpeed: 0.33,
    shieldEvery: 9.0,
    shieldDuration: 1.8,
    moveSpeed: 0.18
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const normalizeAngle=(a)=>{while(a>Math.PI)a-=Math.PI*2;while(a<-Math.PI)a+=Math.PI*2;return a;};
  const mulberry32=(a)=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;};
  const randChoice=(rng,arr)=>arr[Math.floor(rng()*arr.length)];
  const bossPhase = (b)=> b.hp>30?1:b.hp>20?2:b.hp>10?3:4;

  function createHostSim(session) {
    const p1Uid = session.p1Uid;
    const p2Uid = session.p2Uid;

    const rng = mulberry32((Date.now() ^ 0x9e3779b9) >>> 0);

    const st = {
      tick: 0,
      mode: session.mode,
      elapsed: 0,
      wave: 1,

      formation: { dir: 1, xOffset: 0, yOffset: 0, speedBase: 0.10, stepDown: 0.03 },

      players: {},
      enemies: [],
      hazards: [],
      playerBullets: [],
      enemyBullets: [],
      boss: null,

      _hazAcc: 0,
      _eAcc: 0,
      _bossRespawnAcc: 0,
      nextEnemyId: 1,
      nextHazardId: 1,

      rng
    };

    const mkPlayer = (uid, color, x) => ({ uid, color, x, y: 0.9, alive: true, score: 0, shootCooldown: 0 });
    st.players[p1Uid] = mkPlayer(p1Uid, "blue", 0.45);
    if (p2Uid) st.players[p2Uid] = mkPlayer(p2Uid, "red", 0.55);

    let lastInputs = {};
    const applyInputs = (inputs) => { lastInputs = inputs || {}; };

    function spawnFormation(types) {
      const rows=3, cols=6, x0=0.18, y0=0.14, dx=0.11, dy=0.085;
      for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
        const type = randChoice(st.rng, types);
        st.enemies.push({ id:`en_${st.nextEnemyId++}`, type, baseX:x0+c*dx, baseY:y0+r*dy, x:x0+c*dx, y:y0+r*dy, alive:true, fireAcc:0 });
      }
    }

    function spawnBoss() {
      st.boss = {
        alive:true,
        x:BOSS.x, y:BOSS.y,
        hp:BOSS.hpMax, hpMax:BOSS.hpMax,
        time:0, attackAcc:0,
        shieldAcc:0, shieldLeft:0,
        feintQueue:[],
        dashLeft:0, dashDir:1,
      };
    }

    function spawnWave(w) {
      st.enemies = [];
      st.hazards = [];
      st.enemyBullets = [];
      st.playerBullets = [];
      st._hazAcc = 0;
      st._eAcc = 0;

      st.formation.dir = 1; st.formation.xOffset = 0; st.formation.yOffset = 0;
      st.boss = null;

      if (w===1) spawnFormation(["A"]);
      if (w===2) spawnFormation(["A","B","C"]);
      if (w===3) spawnFormation(["B","C"]);
      if (w===4) spawnBoss();
    }
    spawnWave(1);

    function pickAlivePlayer() {
      const arr = Object.values(st.players).filter(p=>p.alive);
      if (!arr.length) return null;
      return arr[Math.floor(st.rng()*arr.length)];
    }

    function updateFormation(dt) {
      const fes = st.enemies.filter(e=>e.alive && (e.type==="A"||e.type==="B"||e.type==="C"));
      if (!fes.length) return;
      let minX=Infinity, maxX=-Infinity;
      for (const e of fes) { const x=e.baseX+st.formation.xOffset; minX=Math.min(minX,x); maxX=Math.max(maxX,x); }
      st.formation.xOffset += st.formation.dir * st.formation.speedBase * dt;
      if (maxX>0.92){ st.formation.dir=-1; st.formation.yOffset += st.formation.stepDown; }
      if (minX<0.08){ st.formation.dir= 1; st.formation.yOffset += st.formation.stepDown; }
      for (const e of fes) {
        const extra=(e.type==="B")?(ENEMY.B.moveSpeed-ENEMY.A.moveSpeed):0;
        e.x = e.baseX + st.formation.xOffset*(1+extra);
        e.y = e.baseY + st.formation.yOffset;
      }
    }

    function updateE(dt) {
      for (const e of st.enemies) {
        if (!e.alive || e.type!=="E") continue;
        e.t=(e.t??0)+dt;
        e.x = e.x0 + Math.sin(e.t*2.2)*0.10;
        e.y += 0.12*dt;
        if (e.y>1.1) e.alive=false;
      }
    }

    function updateHazards(dt) {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        h.y += ENEMY.D.fallSpeed*dt;
        if (h.y>1.1) h.alive=false;
      }
    }

    function spawnHazards(dt) {
      if (st.wave!==3) return;
      st._hazAcc += dt/8;
      if (st._hazAcc<1) return;
      st._hazAcc -= 1;
      st.hazards.push({ id:`hz_${st.nextHazardId++}`, type:"D", x:0.10+st.rng()*0.80, y:-0.05, alive:true });
    }

    function spawnEIfNeeded(dt) {
      if (st.wave!==3) return;
      st._eAcc += dt/5;
      if (st._eAcc<1) return;
      st._eAcc -= 1;
      const x0=0.15+st.rng()*0.70;
      st.enemies.push({ id:`en_${st.nextEnemyId++}`, type:"E", x0, x:x0, y:-0.06, t:0, alive:true, fireAcc:0 });
    }

    function movePlayerBullets(dt) {
      for (const b of st.playerBullets) b.y -= 0.85*dt;
      st.playerBullets = st.playerBullets.filter(b=>b.y>-0.1 && !b.dead);
    }

    function moveEnemyBullets(dt) {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;
        if (b.waveAmp) {
          b.waveT=(b.waveT??0)+dt;
          b.x += Math.sin(b.waveT*b.waveFreq)*b.waveAmp*dt;
        }
        if (b.splitAt!=null) {
          b.life=(b.life??0)+dt;
          if (!b.splitDone && b.life>=b.splitAt) {
            b.splitDone=true;
            const spd=Math.hypot(b.vx,b.vy);
            st.enemyBullets.push({ x:b.x, y:b.y, vx:-0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            st.enemyBullets.push({ x:b.x, y:b.y, vx: 0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            b.dead=true; continue;
          }
        }
        if (b.type==="C_HOMING" && b.homingLeft>0) {
          b.homingLeft-=dt;
          const t = pickAlivePlayer();
          if (t) {
            const dx=t.x-b.x, dy=t.y-b.y;
            const desired=Math.atan2(dy,dx);
            const cur=Math.atan2(b.vy,b.vx);
            const diff=normalizeAngle(desired-cur);
            const maxTurn=2.2*dt;
            const turned=cur+clamp(diff,-maxTurn,maxTurn);
            const spd=Math.hypot(b.vx,b.vy);
            b.vx=Math.cos(turned)*spd;
            b.vy=Math.sin(turned)*spd;
          }
        }
        b.x += b.vx*dt;
        b.y += b.vy*dt;
        if (b.y>1.2 || b.x<-0.2 || b.x>1.2) b.dead=true;
      }
      st.enemyBullets = st.enemyBullets.filter(b=>!b.dead);
    }

    function enemyFire(dt) {
      const alivePlayers = Object.values(st.players).filter(p=>p.alive);
      if (!alivePlayers.length) return;
      for (const e of st.enemies) {
        if (!e.alive) continue;
        if (!(e.type==="A"||e.type==="B"||e.type==="C"||e.type==="E")) continue;
        const cfg = ENEMY[e.type];
        e.fireAcc=(e.fireAcc??0)+cfg.firePerSec*dt;
        while (e.fireAcc>=1) {
          e.fireAcc-=1;
          if (e.type==="C") {
            const t=pickAlivePlayer(); if(!t) break;
            const dx=t.x-e.x, dy=t.y-e.y;
            const ang=Math.atan2(dy,dx);
            const spd=cfg.bulletSpeed;
            st.enemyBullets.push({ x:e.x,y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, type:"C_HOMING", homingLeft:cfg.homingTime, dead:false });
          } else {
            const t=pickAlivePlayer();
            const aim=t?clamp((t.x-e.x)*1.2,-0.25,0.25):0;
            st.enemyBullets.push({ x:e.x,y:e.y, vx:aim, vy:cfg.bulletSpeed, type:`${e.type}_SHOT`, dead:false });
          }
        }
      }
    }

    function collidePlayerBulletsToEnemies() {
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        for (const e of st.enemies) {
          if (!e.alive) continue;
          const dx=e.x-b.x, dy=e.y-b.y;
          if (dx*dx+dy*dy<0.00085) {
            e.alive=false; b.dead=true;
            const p=st.players[b.ownerUid]; if (p) p.score += (SCORE[e.type]??0);
            break;
          }
        }
      }
      st.enemies = st.enemies.filter(e=>e.alive);
    }

    function collideHazardsToPlayers() {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        for (const uid in st.players) {
          const p=st.players[uid]; if(!p.alive) continue;
          const dx=p.x-h.x, dy=p.y-h.y;
          if (dx*dx+dy*dy<0.0016) { p.alive=false; h.alive=false; break; }
        }
      }
      st.hazards = st.hazards.filter(h=>h.alive);
    }

    function collideEnemyBulletsToPlayers() {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;
        for (const uid in st.players) {
          const p=st.players[uid]; if(!p.alive) continue;
          const dx=p.x-b.x, dy=p.y-b.y;
          if (dx*dx+dy*dy<0.0010) { p.alive=false; b.dead=true; break; }
        }
      }
    }

    // Boss patterns
    function doBossAttack(phase, enrage) {
      const patterns = [pRing, pRightSide];
      if (phase>=2) patterns.push(pSnipe, pSplit);
      if (phase>=3) patterns.push(pWave, pHomingWeak, pFeint);
      if (phase>=4) patterns.push(pDash, pSnake);
      const p = randChoice(st.rng, patterns);
      p(enrage);
    }
    function pRing(enrage) {
      const boss=st.boss;
      const phase=bossPhase(boss);
      const n = phase===1?10:phase===2?12:phase===3?14:16;
      const spd=BOSS.baseBulletSpeed*(1+0.08*(phase-1))*enrage;
      for (let i=0;i<n;i++){
        const a=Math.PI*2*(i/n);
        st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_RING", dead:false });
      }
    }
    function pRightSide(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.05*enrage;
      const n=8;
      for (let i=0;i<n;i++){
        const a=(-Math.PI/2)+(i/(n-1))*(Math.PI/2);
        const vx=Math.cos(a)*spd+0.18;
        const vy=Math.sin(a)*spd+0.45;
        st.enemyBullets.push({ x:boss.x,y:boss.y, vx,vy, type:"BOSS_RIGHT", dead:false });
      }
    }
    function pWave(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*enrage;
      const n=6;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.03;
        st.enemyBullets.push({ x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.22, waveFreq:7.0, type:"BOSS_WAVE", dead:false });
      }
    }
    function pFeint(enrage) {
      const boss=st.boss;
      const delay=0.55+(st.rng()*0.45);
      boss.feintQueue.push({
        t: delay,
        pattern: () => {
          const spd=BOSS.baseBulletSpeed*0.95*enrage;
          const n=8;
          for (let i=0;i<n;i++){
            const a=Math.PI*2*(i/n);
            st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_FEINT", dead:false });
          }
        }
      });
    }
    function pSnipe(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      boss.feintQueue.push({
        t: 0.65,
        pattern: () => {
          const dx=target.x-boss.x, dy=target.y-boss.y;
          const a=Math.atan2(dy,dx);
          const spd=BOSS.baseBulletSpeed*1.9*enrage;
          st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_SNIPE", dead:false });
        }
      });
    }
    function pSplit(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.1*enrage;
      st.enemyBullets.push({ x:boss.x,y:boss.y, vx:0, vy:spd, splitAt:0.55, splitDone:false, type:"BOSS_SPLIT", dead:false });
    }
    function pHomingWeak(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      const dx=target.x-boss.x, dy=target.y-boss.y;
      const a=Math.atan2(dy,dx);
      const spd=BOSS.baseBulletSpeed*1.05*enrage;
      st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"C_HOMING", homingLeft:0.75, dead:false });
    }
    function pDash(enrage) {
      const boss=st.boss;
      boss.dashLeft = 0.8*Math.min(1.4,enrage);
      boss.dashDir = (st.rng()<0.5) ? -1 : 1;
    }
    function pSnake(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*0.95*enrage;
      const n=4;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.05;
        st.enemyBullets.push({ x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.30, waveFreq:9.5, type:"BOSS_SNAKE", dead:false });
      }
    }

    function updateBoss(dt, wave4Elapsed) {
      const boss = st.boss;
      if (!boss || !boss.alive) return;

      boss.time += dt;
      const over = Math.max(0, wave4Elapsed - WAVE_DUR[3]);
      const enrage = 1 + over * 0.012;

      // movement
      if (boss.dashLeft>0) {
        boss.dashLeft -= dt;
        boss.x += boss.dashDir*(BOSS.moveSpeed*3.2)*dt;
        if (boss.x<0.12){ boss.x=0.12; boss.dashDir=1; }
        if (boss.x>0.88){ boss.x=0.88; boss.dashDir=-1; }
      } else {
        boss.x += Math.sin(boss.time*0.9)*0.06*dt;
        boss.x = clamp(boss.x,0.12,0.88);
      }

      // shield
      boss.shieldAcc += dt;
      if (boss.shieldLeft>0) boss.shieldLeft -= dt;
      if (boss.shieldAcc >= BOSS.shieldEvery) {
        boss.shieldAcc = 0;
        boss.shieldLeft = BOSS.shieldDuration;
      }

      // feint queue
      for (const f of boss.feintQueue) f.t -= dt;
      while (boss.feintQueue.length && boss.feintQueue[0].t <= 0) {
        const fire = boss.feintQueue.shift();
        if (fire) fire.pattern();
      }

      const phase = bossPhase(boss);
      const baseAttacksPerSec = phase===1?0.55:phase===2?0.75:phase===3?0.95:1.20;
      boss.attackAcc += baseAttacksPerSec * Math.min(2.2,enrage) * dt;

      while (boss.attackAcc >= 1) { boss.attackAcc -= 1; doBossAttack(phase, Math.min(2.2,enrage)); }
    }

    function collidePlayerBulletsToBoss() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        const dx=boss.x-b.x, dy=boss.y-b.y;
        if (dx*dx+dy*dy<0.0032) {
          b.dead = true;
          if (boss.shieldLeft>0) continue;
          boss.hp -= 1;
          const p=st.players[b.ownerUid]; if (p) p.score += SCORE.BOSS_HIT;
          if (boss.hp<=0) {
            const p2=st.players[b.ownerUid]; if (p2) p2.score += SCORE.BOSS_KILL;
            boss.alive = false; // 死亡
          }
        }
      }
    }

    function collideBossToPlayers() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const uid in st.players) {
        const p=st.players[uid]; if(!p.alive) continue;
        const dx=p.x-boss.x, dy=p.y-boss.y;
        if (dx*dx+dy*dy<0.0040) p.alive=false;
      }
    }

    function isAllDead() {
      return Object.values(st.players).every(p=>!p.alive);
    }

    function step(dt) {
      st.tick++;
      st.elapsed += dt;

      const t = st.elapsed;
      const tW1=WAVE_DUR[0], tW2=tW1+WAVE_DUR[1], tW3=tW2+WAVE_DUR[2];

      let newWave = st.wave;
      if (t < tW1) newWave=1;
      else if (t < tW2) newWave=2;
      else if (t < tW3) newWave=3;
      else newWave=4;

      if (newWave !== st.wave) { st.wave = newWave; spawnWave(newWave); }

      // players
      for (const uid in st.players) {
        const p=st.players[uid];
        if (!p.alive) continue;
        const inp = lastInputs?.[uid] || {};
        const speed=0.45;
        if (inp.left) p.x -= speed*dt;
        if (inp.right) p.x += speed*dt;
        p.x = clamp(p.x, 0.05, 0.95);

        p.shootCooldown = Math.max(0, p.shootCooldown - dt);
        if (inp.shoot && p.shootCooldown===0) {
          st.playerBullets.push({ x:p.x, y:p.y-0.03, ownerUid:uid });
          p.shootCooldown = SHOOT_CD;
        }
      }

      if (st.wave<=3) {
        updateFormation(dt);
        updateE(dt);
        updateHazards(dt);
        enemyFire(dt);
        spawnHazards(dt);
        spawnEIfNeeded(dt);

        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideHazardsToPlayers();
        collidePlayerBulletsToEnemies();
      } else {
        const wave4Elapsed = Math.max(0, st.elapsed - tW3);

        // "全員死ぬまで終わらない"：ボスが倒れても復活する
        if ((!st.boss || !st.boss.alive) && !isAllDead()) {
          st._bossRespawnAcc += dt;
          if (st._bossRespawnAcc >= 3.0) { st._bossRespawnAcc = 0; spawnBoss(); }
        } else {
          st._bossRespawnAcc = 0;
        }

        updateBoss(dt, wave4Elapsed);
        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideBossToPlayers();
        collidePlayerBulletsToBoss();
      }

      movePlayerBullets(dt);
      st.playerBullets = st.playerBullets.filter(b=>!b.dead);
    }

    function snapshot() {
      const playersArr = Object.values(st.players).map(p=>({ uid:p.uid, x:p.x, y:p.y, alive:p.alive, score:p.score, color:p.color, shootCooldown:p.shootCooldown }));
      const boss = st.boss ? {
        x:st.boss.x, y:st.boss.y, alive:st.boss.alive,
        hp:st.boss.hp, hpMax:st.boss.hpMax,
        shieldLeft:st.boss.shieldLeft,
        phase: bossPhase(st.boss),
      } : null;

      return {
        tick: st.tick,
        mode: st.mode,
        wave: st.wave,
        elapsed: Math.floor(st.elapsed*1000)/1000,
        players: playersArr,
        enemies: st.enemies.filter(e=>e.alive).map(e=>({x:e.x,y:e.y,type:e.type})),
        hazards: st.hazards.filter(h=>h.alive).map(h=>({x:h.x,y:h.y,type:h.type})),
        playerBullets: st.playerBullets.filter(b=>!b.dead).map(b=>({x:b.x,y:b.y,ownerUid:b.ownerUid})),
        enemyBullets: st.enemyBullets.filter(b=>!b.dead).map(b=>({x:b.x,y:b.y,type:b.type})),
        boss,
        sentAt: Date.now()
      };
    }

    return { step, snapshot, applyInputs, isAllDead };
  }

  // ---------- Score consent + leaderboard ----------
  async function maybeSubmitScoreFlow({ uid, session, game }) {
    if (!session?.sessionId) return;
    const sid = session.sessionId;

    const isPlayer = session.p1Uid === uid || session.p2Uid === uid;
    if (!isPlayer) return;

    const me = (game?.players || []).find(p => p.uid === uid);
    const myScore = me?.score ?? 0;

    const subRef = ref(db, PATHS.submissions(sid));
    const existing = (await get(subRef)).val();
    if (!existing) {
      await set(subRef, {
        sessionId: sid,
        mode: session.mode,
        p1Uid: session.p1Uid,
        p2Uid: session.p2Uid || null,
        p1Consent: null,
        p2Consent: null,
        status: "pending",
        scoreP1: null,
        scoreP2: null,
        createdAt: Date.now()
      });
    }

    const subNow = (await get(subRef)).val();
    const isP1 = session.p1Uid === uid;
    const consentKey = isP1 ? "p1Consent" : "p2Consent";
    const scoreKey = isP1 ? "scoreP1" : "scoreP2";

    if (subNow?.[consentKey] !== null && subNow?.[consentKey] !== undefined) return;

    const ok = await modalAsk("スコアをランキングに載せますか？", `あなたのスコア: ${myScore}`);
    await update(subRef, { [consentKey]: ok, [scoreKey]: myScore });
  }

  async function postToLeaderboardIfNeeded(session) {
    if (!session?.sessionId) return;
    const sid = session.sessionId;
    const sub = (await get(ref(db, PATHS.submissions(sid)))).val();
    if (!sub || sub.status === "posted") return;

    if (session.mode === "solo") {
      if (sub.p1Consent !== true) {
        await update(ref(db, PATHS.submissions(sid)), { status: "rejected" });
        return;
      }
    } else {
      if (sub.p1Consent === false || sub.p2Consent === false) {
        await update(ref(db, PATHS.submissions(sid)), { status: "rejected" });
        return;
      }
      if (sub.p1Consent !== true || sub.p2Consent !== true) return;
    }

    const total = session.mode === "multi"
      ? ((sub.scoreP1 ?? 0) + (sub.scoreP2 ?? 0))
      : (sub.scoreP1 ?? 0);

    const name1 = await getMyName(session.p1Uid);
    const name2 = session.p2Uid ? await getMyName(session.p2Uid) : "";
    const displayName = session.mode === "multi" ? `${name1}&${name2}` : name1;

    const lbRef = ref(db, PATHS.leaderboardTop);
    const lbSnap = await get(lbRef);
    const arr = Array.isArray(lbSnap.val()) ? lbSnap.val() : [];
    arr.push({ name: displayName || "no-name", score: total, at: Date.now() });
    arr.sort((a,b)=> (b.score??0)-(a.score??0));
    await set(lbRef, arr.slice(0, 10));

    await update(ref(db, PATHS.submissions(sid)), { status: "posted", postedAt: Date.now(), postedScore: total, postedName: displayName });
  }

  // ---------- Host loop + idle timeout ----------
  let hostRunning = false;
  let hostStop = null;

  async function startHostLoopIfNeeded(uid, session) {
    const isHost = session?.hostUid === uid;
    const isPlaying = session?.state === "playing";
    if (hostRunning) {
      if (!isHost || !isPlaying) { hostRunning=false; if(hostStop)hostStop(); hostStop=null; }
      return;
    }
    if (!isHost || !isPlaying) return;

    hostRunning = true;
    const sim = createHostSim(session);
    await set(ref(db, PATHS.sessionGame), sim.snapshot());

    const hz = 15;
    const intervalMs = Math.floor(1000 / hz);
    const timer = setInterval(async () => {
      const s = (await get(ref(db, PATHS.sessionCurrent))).val();
      if (!s || s.state !== "playing") return;

      // 60秒無操作 = リタイア扱い（p1/p2両方が無操作）
      const inputs = (await get(ref(db, `session/current/inputs`))).val() || {};
      const now = Date.now();
      const uids = [s.p1Uid, s.p2Uid].filter(Boolean);
      const lastTimes = uids.map(u => inputs?.[u]?.t ?? 0);
      const allIdle = uids.length > 0 && lastTimes.every(t => (now - t) >= 60000);
      if (allIdle) {
        await update(ref(db, PATHS.sessionCurrent), { state:"finished", finishedReason:"idle_timeout", updatedAt: serverTimestamp() });
        return;
      }

      sim.applyInputs(inputs);
      sim.step(intervalMs / 1000);

      if (sim.isAllDead()) {
        await update(ref(db, PATHS.sessionCurrent), { state:"finished", finishedReason:"all_dead", updatedAt: serverTimestamp() });
        return;
      }

      await set(ref(db, PATHS.sessionGame), sim.snapshot());
    }, intervalMs);

    hostStop = () => clearInterval(timer);
  }

  // ---------- Auto cleanup when session is stale / no-one online ----------
  async function maybeAutoCleanup(uid, session) {
    if (!session || session.state === "idle") return;

    // stateがあるのに host/p1 がいない（offline）なら cleanup を試みる
    const leader = chooseLeaderUid(session);
    const canCleanup = (uid === session.hostUid) || (uid === leader);

    if (!canCleanup) return;

    const hostOn = await isOnline(session.hostUid);
    const p1On = await isOnline(session.p1Uid);
    const p2On = session.p2Uid ? await isOnline(session.p2Uid) : false;

    // recruiting/preparing/playing のときに、主要人物が全員オフラインなら消す
    const anyImportantOnline = hostOn || p1On || p2On;

    // finished/resetting で残骸になってる可能性もあるので、誰もいないなら消す
    if (!anyImportantOnline) {
      showAnn("セッションをリセットします", "参加者がいないため自動リセットします");
      await remove(ref(db, PATHS.sessionCurrent));
      await remove(ref(db, PATHS.sessionGame));
      hideAnn();
      return;
    }

    // playingなのに gameデータが無い/古い場合も残骸扱い
    if (session.state === "playing") {
      const g = (await get(ref(db, PATHS.sessionGame))).val();
      const tooOld = !g?.sentAt || (Date.now() - g.sentAt) > 15000;
      if (tooOld) {
        showAnn("セッションをリセットします", "ゲームデータが停止しているため自動リセットします");
        await update(ref(db, PATHS.sessionCurrent), { state:"finished", finishedReason:"stale_game", updatedAt: serverTimestamp() });
      }
    }
  }

  // ---------- Reset flow ----------
  async function hostResetFlowIfNeeded(uid, session) {
    if (!session) return;
    const leader = chooseLeaderUid(session);
    const canReset = (uid === session.hostUid) || (uid === leader);
    if (!canReset) return;

    if (session.state !== "finished") return;

    await update(ref(db, PATHS.sessionCurrent), { state:"resetting", updatedAt: serverTimestamp() });
    showAnn("データをリセットします", "プレイヤーがロビーに戻るまで待ってください");

    const t0 = Date.now();
    while (Date.now() - t0 < 20000) {
      const ss = (await get(ref(db, PATHS.sessionCurrent))).val();
      if (!ss || ss.state !== "resetting") break;
      const cs = ss.clientState || {};
      const need = [ss.p1Uid, ss.p2Uid].filter(Boolean);
      const ok = need.every(u => cs[u] === "lobby" || cs[u] === "offline");
      if (ok) break;
      await sleep(400);
    }

    await remove(ref(db, PATHS.sessionCurrent));
    await remove(ref(db, PATHS.sessionGame));
    hideAnn();
  }

  // ---------- Bind session UI ----------
  function bindLobbyUI(uid) {
    const sessionRef = ref(db, PATHS.sessionCurrent);

    ui.watchBtn.onclick = async () => {
      const s = (await get(sessionRef)).val();
      if (s?.state === "playing") await setClientState(uid, "watching");
    };

    ui.soloBtn.onclick = async () => {
      const myName = await getMyName(uid);
      if (!myName) return;
      const s = (await get(sessionRef)).val();
      if (s?.state && s.state !== "idle") return;
      const sessionId = `sess_${Date.now()}_${uuidShort()}`;
      await set(sessionRef, {
        sessionId,
        state:"preparing",
        mode:"solo",
        hostUid: uid,
        p1Uid: uid,
        p2Uid: null,
        recruiting: null,
        ready: { [uid]: false },
        clientState: { [uid]: "preparing" },
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
    };

    ui.multiBtn.onclick = async () => {
      const myName = await getMyName(uid);
      if (!myName) return;
      const s = (await get(sessionRef)).val();
      if (s?.state && s.state !== "idle") return;
      const sessionId = `sess_${Date.now()}_${uuidShort()}`;
      const promptId = `prompt_${Date.now()}_${uuidShort()}`;
      await set(sessionRef, {
        sessionId,
        state:"recruiting",
        mode:"multi",
        hostUid: uid,
        p1Uid: uid,
        p2Uid: null,
        recruiting: { promptId, joinerUid: null },
        ready: { [uid]: false },
        clientState: { [uid]: "preparing" },
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
    };

    ui.readyBtn.onclick = async () => {
      await set(ref(db, PATHS.sessionReady(uid)), true);
      await setClientState(uid, "preparing");
      const s = (await get(sessionRef)).val();
      if (!s || s.hostUid !== uid) return;
      if (s.state !== "preparing") return;

      const p1 = s.p1Uid;
      const p2 = s.p2Uid;
      const ready = s.ready || {};
      const ok1 = !!ready?.[p1];
      const ok2 = (s.mode === "solo") ? true : !!ready?.[p2];
      if (ok1 && ok2) await update(sessionRef, { state:"playing", updatedAt: serverTimestamp() });
    };

    ui.leaveBtn.onclick = async () => {
      const s = (await get(sessionRef)).val();
      if (!s) return;
      const isPlayer = s.p1Uid===uid || s.p2Uid===uid;
      if (!isPlayer) return;
      await remove(sessionRef);
      await remove(ref(db, PATHS.sessionGame));
    };

    ui.retireBtn.onclick = async () => {
      const s = (await get(sessionRef)).val();
      if (!s || s.hostUid !== uid) return;
      if (s.state !== "playing") return;
      await update(sessionRef, { state:"finished", finishedReason:"retire", updatedAt: serverTimestamp() });
    };

    onValue(sessionRef, async (snap) => {
      const s = snap.val() || { state:"idle" };
      ui.sessionDebug.textContent = JSON.stringify(s, null, 2);
      ui.statusLine.textContent = `${s.state}${s.mode ? ` (${s.mode})` : ""}`;

      const myName = await getMyName(uid);
      const nameOk = !!myName;
      ui.nameHint.textContent = nameOk ? `保存済み: ${myName}` : "名前を保存するとロビー操作できます";

      // ここがバグ修正ポイント：残骸セッションを自動修復する
      await maybeAutoCleanup(uid, s);

      const busy = s.state !== "idle";
      ui.soloBtn.disabled = !nameOk || busy;
      ui.multiBtn.disabled = !nameOk || busy;

      if (!nameOk) ui.playHint.textContent = "名前を保存してください（保存後にプレイ選択できます）";
      else if (!busy) ui.playHint.textContent = "プレイ可能です（ソロ / マルチ）";
      else ui.playHint.textContent = "現在他の方がプレイ中です。観戦のみ可能です。";

      document.body.classList.toggle("playing", s.state === "playing");

      const isPlayer = s.p1Uid===uid || s.p2Uid===uid;
      const isHost = s.hostUid===uid;

      let role = "spectator";
      if (isHost) role = "host";
      if (isPlayer && !isHost) role = "player";
      ui.roleTag.textContent = `role:${role}`;

      ui.readyBtn.style.display = (isPlayer && s.state === "preparing") ? "" : "none";
      ui.leaveBtn.style.display = (isPlayer && (s.state==="recruiting" || s.state==="preparing")) ? "" : "none";
      ui.retireBtn.style.display = (isHost && s.state==="playing" && s.mode==="multi") ? "" : "none";

      if (s.state==="idle") { ui.screenTitle.textContent="ロビー"; ui.screenSub.textContent=""; hideAnn(); }
      if (s.state==="recruiting") { ui.screenTitle.textContent="準備中"; ui.screenSub.textContent="マルチ参加者を募集しています"; hideAnn(); }
      if (s.state==="preparing") { ui.screenTitle.textContent="準備中"; ui.screenSub.textContent="準備完了を押すと開始します"; hideAnn(); }
      if (s.state==="playing") { ui.screenTitle.textContent="プレイ中"; ui.screenSub.textContent="A/D移動・Space発射"; hideAnn(); }
      if (s.state==="resetting") { ui.screenTitle.textContent="リセット中"; ui.screenSub.textContent=""; showAnn("データをリセットします", "少々お待ちください"); }
      if (s.state==="finished") { ui.screenTitle.textContent="終了"; ui.screenSub.textContent="ロビーに戻ります"; showAnn("ゲーム終了", `理由: ${s.finishedReason||"?"}\nスコア送信確認中…`); }

      if (s.state==="playing") await setClientState(uid, isPlayer ? "playing" : "watching");
      if (!s || s.state==="idle" || s.state==="resetting") await setClientState(uid, "lobby");

      // recruiting prompt
      if (s.state==="recruiting" && s.mode==="multi") {
        const already = (s.p1Uid===uid || s.p2Uid===uid);
        if (!already && !s.recruiting?.joinerUid) {
          const ok = await modalAsk("マルチに参加しますか？（早押し）", "最初にOKした1人だけ参加できます");
          if (!ok) return;
          const joinerRef = ref(db, PATHS.sessionRecruitingJoiner);
          const tx = await runTransaction(joinerRef, (cur) => (cur ? undefined : uid));
          if (!tx.committed) {
            showAnn("間に合いませんでした", "ロビーに戻ります");
            setTimeout(hideAnn, 1200);
            return;
          }
          const now = (await get(sessionRef)).val();
          if (!now || now.state !== "recruiting") return;
          await update(sessionRef, {
            state:"preparing",
            p2Uid: uid,
            ready: { ...(now.ready||{}), [uid]: false },
            clientState: { ...(now.clientState||{}), [uid]: "preparing" },
            updatedAt: serverTimestamp()
          });
        }
      }

      await startHostLoopIfNeeded(uid, s);

      // finished: consent flow
      if (s.state==="finished") {
        const game = (await get(ref(db, PATHS.sessionGame))).val();
        await maybeSubmitScoreFlow({ uid, session: s, game });

        // host(or leader) posts when ready
        const leader = chooseLeaderUid(s);
        if (uid === s.hostUid || uid === leader) await postToLeaderboardIfNeeded(s);

        await hostResetFlowIfNeeded(uid, s);
      }
    });
  }

  // ---------- Subscribe & draw game state ----------
  function bindGameDraw(uid) {
    onValue(ref(db, PATHS.sessionGame), (snap) => {
      const g = snap.val();
      if (!g) { drawIdle("ロビー / 観戦待機中"); return; }
      drawState(g, uid);
    });
  }

  // ---------- Presence bind ----------
  async function bindPresence(uid) {
    const presRef = ref(db, PATHS.presence(uid));
    await set(presRef, { online:true, lastSeen: serverTimestamp() });
    onDisconnect(presRef).set({ online:false, lastSeen: serverTimestamp() });
  }

  // ---------- Start ----------
  await signInAnonymously(auth);

  onAuthStateChanged(auth, async (user) => {
    if (!user) return;
    const uid = user.uid;
    ui.me.textContent = `uid: ${uid.slice(0, 8)}…`;

    await bindPresence(uid);
    bindName(uid);
    bindLeaderboard();
    bindInputSender(uid);
    bindLobbyUI(uid);
    bindGameDraw(uid);

    await setClientState(uid, "name");
    onDisconnect(ref(db, PATHS.sessionClientState(uid))).set("offline");
  });
</script>
</body>
</html>
