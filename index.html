<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Invader Rooms (RTDB) - Single File Complete</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0e14; color:#e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; }

    #app { display:grid; grid-template-rows:auto 1fr; height:100%; }
    header { padding:10px 12px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #1f2a3a; }
    header b { font-weight: 900; letter-spacing:.2px; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#a8b3c7; }
    .tag { padding:2px 8px; border-radius: 999px; border:1px solid #1f2a3a; background:#0b1220; color:#a8b3c7; font-size:12px; }
    #statusLine { margin-left:auto; color:#a8b3c7; }

    button { background:#2b69ff; color:white; border:0; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800; }
    button.secondary { background:#223047; }
    button.danger { background:#b42318; }
    button.ghost { background:transparent; border:1px solid #1f2a3a; color:#a8b3c7; }
    button.small { padding:6px 10px; border-radius:10px; font-weight:700; font-size:12px; }
    button[disabled] { opacity:.45; cursor:not-allowed; }

    input { width: 100%; box-sizing:border-box; padding:12px 12px; border-radius:12px; border:1px solid #26344a; background:#0b1220; color:#e8eefc; font-size:16px; }
    .muted { color:#a8b3c7; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:10px; }

    .card { border:1px solid #1f2a3a; border-radius:16px; padding:14px; background:#0e1420; }
    .card.thin { background: rgba(14,20,32,.45); border-color: rgba(31,42,58,.55); backdrop-filter: blur(6px); }

    /* screens */
    .screen { display:none; height:100%; }
    .screen.active { display:block; }

    /* name screen */
    #nameScreen .wrap { height:100%; display:flex; align-items:center; justify-content:center; padding:18px; }
    #nameScreen .panel { width:min(520px, 92vw); }
    #nameScreen h1 { margin:0 0 6px 0; font-size: 26px; }

    /* lobby */
    #lobbyMain { height:100%; box-sizing:border-box; padding:14px; display:grid; grid-template-columns: 340px 1fr 320px; gap:14px; min-height:0; }
    #leftCol, #midCol, #rightCol { min-height:0; }
    #roomsList { overflow:auto; max-height: calc(100vh - 170px); }
    .roomRow {
      display:grid; grid-template-columns: 1fr auto; gap:10px;
      border:1px solid rgba(31,42,58,.7);
      border-radius:14px;
      padding:10px 10px;
      background: rgba(11,18,32,.55);
      margin-bottom:10px;
    }
    .roomTop { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .roomMeta { font-size:12px; color:#a8b3c7; margin-top:4px; }
    .roomBtns { display:flex; gap:8px; justify-content:flex-end; align-items:center; flex-wrap:wrap; }

    /* game */
    #gameWrap { height:100%; display:flex; flex-direction:column; }
    #gameTopBar {
      padding:10px 12px; border-bottom:1px solid #1f2a3a;
      display:flex; align-items:center; gap:10px;
    }
    #gameTopBar .spacer { flex:1; }
    #canvasWrap { flex:1; min-height:0; position:relative; }
    canvas { width:100%; height:100%; display:block; background:#05070b; }

    #hud {
      position:absolute; left:10px; top:10px;
      background: rgba(10,14,22,.72);
      border:1px solid #1f2a3a;
      padding:10px 12px;
      border-radius:16px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:#e8eefc;
      min-width: 300px;
    }
    #ann { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.60); }
    #ann .card { width:min(560px, 92vw); }

    /* modal */
    #modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.60); z-index: 50; }
    #modal .card { width:min(560px, 92vw); }
    #modal .row { justify-content:flex-end; }

    /* subtle star bg (lobby) */
    #stars {
      position: fixed; inset: 0; z-index: -1;
      background:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.10), transparent 40%),
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.08), transparent 40%),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.06), transparent 40%),
        linear-gradient(#070a10, #0b0e14);
      filter: saturate(1.1);
    }
  </style>
</head>
<body>
<div id="stars"></div>
<div id="app">
  <header>
    <b>Invader Rooms</b>
    <small class="mono" id="me"></small>
    <span class="tag" id="adminTag" style="display:none;">ADMIN</span>
    <span class="tag" id="roomTag" style="display:none;">room:-</span>
    <div id="statusLine"></div>
  </header>

  <!-- Name screen -->
  <section id="nameScreen" class="screen active">
    <div class="wrap">
      <div class="panel card">
        <h1>名前を入力</h1>
        <p class="muted" style="margin:0 0 12px 0;">最初に1回だけ必要です（後で変更可）。</p>
        <input id="nameInput" placeholder="表示名（20文字まで）" maxlength="20" />
        <div class="row" style="margin-top:12px; justify-content:flex-end;">
          <button id="saveNameBtn">決定</button>
        </div>
        <div class="muted" id="nameHint" style="margin-top:10px;"></div>
      </div>
    </div>
  </section>

  <!-- Lobby screen -->
  <section id="lobbyScreen" class="screen">
    <div id="lobbyMain">
      <!-- left -->
      <div id="leftCol" class="col">
        <div class="card">
          <div style="font-weight:900; font-size:18px;">ロビー</div>
          <div class="muted" style="margin-top:8px; line-height:1.5;">
            操作：<b>A/D</b> 移動、<b>Space</b> 発射（CD 3秒）<br/>
            Wave：30/40/90/140秒（以降ボス継続・激化）<br/>
            終了：全員死亡 or ホストリタイア
          </div>
          <div class="row" style="margin-top:12px;">
            <button id="createSoloBtn">ソロ部屋を作る</button>
            <button id="createMultiBtn">マルチ部屋を作る</button>
          </div>
          <div class="muted" id="createHint" style="margin-top:10px;"></div>

          <div class="row" style="margin-top:14px; justify-content:space-between;">
            <button id="changeNameBtn" class="ghost">名前を変更</button>
            <span class="muted" id="myNameLabel"></span>
          </div>
        </div>

        <div class="card thin">
          <div class="row" style="justify-content:space-between;">
            <div class="muted" style="font-weight:800;">運営</div>
            <div class="tag muted">pw 1122</div>
          </div>
          <div class="row" style="margin-top:10px;">
            <input id="adminPw" placeholder="1122" inputmode="numeric" maxlength="8" style="width:120px; padding:8px 10px; font-size:13px;" />
            <button id="adminEnterBtn" class="secondary small">決定</button>
            <button id="adminExitBtn" class="ghost small" style="display:none;">解除</button>
          </div>
          <div class="muted" style="margin-top:8px; font-size:12px;">
            運営はこの端末だけ（ローカル）で有効になります。
          </div>
        </div>
      </div>

      <!-- middle -->
      <div id="midCol" class="col">
        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div style="font-weight:900; font-size:18px;">部屋一覧</div>
            <span class="tag">最大5部屋</span>
          </div>
          <div class="muted" style="margin-top:6px;">
            参加または観戦できます（誰かがプレイ中でも別部屋ならプレイ可能）
          </div>
          <div id="roomsList" style="margin-top:12px;"></div>
        </div>
      </div>

      <!-- right -->
      <div id="rightCol" class="col">
        <div class="card thin" style="min-height:0;">
          <div class="row" style="justify-content:space-between;">
            <div class="muted" style="font-weight:900;">ランキング（上位）</div>
            <span class="tag">Realtime</span>
          </div>
          <div id="leaderboard" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- Game screen -->
  <section id="gameScreen" class="screen">
    <div id="gameWrap">
      <div id="gameTopBar">
        <span class="tag" id="screenTitle">GAME</span>
        <span class="tag" id="youTag">YOU:-</span>
        <span class="tag" id="modeTag">mode:-</span>
        <span class="tag" id="stateTag">state:-</span>
        <div class="spacer"></div>
        <button id="readyBtn" class="secondary" style="display:none;">準備完了</button>
        <button id="retireBtn" class="danger" style="display:none;">リタイア（ホスト）</button>
        <button id="leaveRoomBtn" class="secondary">部屋を出る</button>
      </div>

      <div id="canvasWrap">
        <canvas id="game"></canvas>

        <div id="hud" style="display:none;">
          <div id="hudLine1"></div>
          <div id="hudLine2" style="margin-top:4px;"></div>
          <div id="hudLine3" class="muted" style="margin-top:6px;"></div>
        </div>

        <div id="ann">
          <div class="card">
            <div style="font-weight:900; margin-bottom:6px;" id="annTitle"></div>
            <div class="muted" id="annBody"></div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- modal -->
<div id="modal">
  <div class="card">
    <div style="font-weight:900; margin-bottom:6px;" id="modalTitle"></div>
    <div class="muted" style="margin-bottom:10px;" id="modalBody"></div>
    <div class="row">
      <button id="modalNo" class="secondary">いいえ</button>
      <button id="modalYes">はい</button>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getDatabase, ref, onValue, get, set, update, remove, runTransaction, serverTimestamp, onDisconnect, query, limitToLast, orderByChild } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
    authDomain: "suisougaku-bdcc0.firebaseapp.com",
    databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com",
    projectId: "suisougaku-bdcc0",
    storageBucket: "suisougaku-bdcc0.firebasestorage.app",
    messagingSenderId: "636001978886",
    appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
    measurementId: "G-Y04PFJ9BQ6"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  const $ = (q) => document.querySelector(q);
  const ui = {
    me: $("#me"),
    adminTag: $("#adminTag"),
    roomTag: $("#roomTag"),
    statusLine: $("#statusLine"),

    nameScreen: $("#nameScreen"),
    lobbyScreen: $("#lobbyScreen"),
    gameScreen: $("#gameScreen"),

    nameInput: $("#nameInput"),
    saveNameBtn: $("#saveNameBtn"),
    nameHint: $("#nameHint"),

    myNameLabel: $("#myNameLabel"),
    changeNameBtn: $("#changeNameBtn"),

    createSoloBtn: $("#createSoloBtn"),
    createMultiBtn: $("#createMultiBtn"),
    createHint: $("#createHint"),

    roomsList: $("#roomsList"),
    leaderboard: $("#leaderboard"),

    adminPw: $("#adminPw"),
    adminEnterBtn: $("#adminEnterBtn"),
    adminExitBtn: $("#adminExitBtn"),

    // game
    screenTitle: $("#screenTitle"),
    youTag: $("#youTag"),
    modeTag: $("#modeTag"),
    stateTag: $("#stateTag"),
    readyBtn: $("#readyBtn"),
    retireBtn: $("#retireBtn"),
    leaveRoomBtn: $("#leaveRoomBtn"),

    canvas: $("#game"),
    hud: $("#hud"),
    hudLine1: $("#hudLine1"),
    hudLine2: $("#hudLine2"),
    hudLine3: $("#hudLine3"),

    ann: $("#ann"),
    annTitle: $("#annTitle"),
    annBody: $("#annBody"),

    modal: $("#modal"),
    modalTitle: $("#modalTitle"),
    modalBody: $("#modalBody"),
    modalYes: $("#modalYes"),
    modalNo: $("#modalNo"),
  };

  function setScreen(name) {
    ui.nameScreen.classList.toggle("active", name === "name");
    ui.lobbyScreen.classList.toggle("active", name === "lobby");
    ui.gameScreen.classList.toggle("active", name === "game");
  }

  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  function uuidShort() { return Math.random().toString(16).slice(2, 10); }
  function showAnn(title, body) {
    ui.annTitle.textContent = title;
    ui.annBody.textContent = body;
    ui.ann.style.display = "flex";
  }
  function hideAnn(){ ui.ann.style.display = "none"; }

  function showModal(title, body) {
    ui.modalTitle.textContent = title;
    ui.modalBody.textContent = body;
    ui.modal.style.display = "flex";
  }
  function hideModal(){ ui.modal.style.display = "none"; }
  function modalAsk(title, body) {
    return new Promise((resolve) => {
      showModal(title, body);
      const yes = () => { cleanup(); resolve(true); };
      const no = () => { cleanup(); resolve(false); };
      const cleanup = () => {
        ui.modalYes.removeEventListener("click", yes);
        ui.modalNo.removeEventListener("click", no);
        hideModal();
      };
      ui.modalYes.addEventListener("click", yes);
      ui.modalNo.addEventListener("click", no);
    });
  }

  // ---------------- Admin mode (local) ----------------
  let adminMode = (localStorage.getItem("inv_admin") === "1");
  function setAdminMode(v) {
    adminMode = v;
    localStorage.setItem("inv_admin", v ? "1" : "0");
    ui.adminTag.style.display = v ? "" : "none";
    ui.adminExitBtn.style.display = v ? "" : "none";
  }
  setAdminMode(adminMode);

  ui.adminEnterBtn.onclick = () => {
    if (ui.adminPw.value.trim() === "1122") {
      setAdminMode(true);
      ui.adminPw.value = "";
    } else alert("パスワードが違います");
  };
  ui.adminExitBtn.onclick = () => setAdminMode(false);

  // ---------------- Paths ----------------
  const PATHS = {
    presence: (uid) => `presence/${uid}`,
    names: (uid) => `lobby/names/${uid}`,
    leaderboardTop: `leaderboard/top`,

    roomsIndex: `rooms_index`,
    room: (roomId) => `rooms/${roomId}`,
    roomIndex: (roomId) => `rooms_index/${roomId}`,

    roomGame: (roomId) => `rooms/${roomId}/game`,
    roomInputs: (roomId, uid) => `rooms/${roomId}/inputs/${uid}`,
    roomReady: (roomId, uid) => `rooms/${roomId}/ready/${uid}`,
    roomRecruitJoiner: (roomId) => `rooms/${roomId}/recruiting/joinerUid`,
    roomClientState: (roomId, uid) => `rooms/${roomId}/clientState/${uid}`,

    submissions: (sid) => `submissions/${sid}`,
  };

  // ---------------- Presence ----------------
  async function bindPresence(uid) {
    const presRef = ref(db, PATHS.presence(uid));
    await set(presRef, { online: true, lastSeen: serverTimestamp() });
    onDisconnect(presRef).set({ online: false, lastSeen: serverTimestamp() });
  }
  async function isOnline(uid) {
    if (!uid) return false;
    const snap = await get(ref(db, PATHS.presence(uid)));
    return !!snap.val()?.online;
  }

  // ---------------- Name ----------------
  async function getMyName(uid) {
    const snap = await get(ref(db, PATHS.names(uid)));
    const v = snap.val();
    return (typeof v === "string" && v.trim()) ? v.trim() : "";
  }
  async function setMyName(uid, name) {
    await set(ref(db, PATHS.names(uid)), name);
  }

  // ---------------- Leaderboard ----------------
  function bindLeaderboard() {
    onValue(ref(db, PATHS.leaderboardTop), (snap) => {
      const data = snap.val() || [];
      ui.leaderboard.innerHTML = "";
      if (!Array.isArray(data) || data.length === 0) {
        ui.leaderboard.textContent = "まだ記録がありません";
        return;
      }
      const ol = document.createElement("ol");
      ol.style.margin = "0 0 0 18px";
      for (const row of data) {
        const li = document.createElement("li");
        li.textContent = `${row.name ?? "?"} - ${row.score ?? 0}`;
        ol.appendChild(li);
      }
      ui.leaderboard.appendChild(ol);
    });
  }

  // ---------------- Game draw ----------------
  const ctx = ui.canvas.getContext("2d");
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = ui.canvas.getBoundingClientRect();
    ui.canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    ui.canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function toScreen(xNorm, yNorm) {
    const w = ui.canvas.getBoundingClientRect().width;
    const h = ui.canvas.getBoundingClientRect().height;
    return { x: xNorm * w, y: yNorm * h };
  }

  function drawIdle(text) {
    resizeCanvas();
    ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
    ctx.fillStyle = "#9fb0cc";
    ctx.font = "16px system-ui";
    ctx.fillText(text, 16, 28);
    ui.hud.style.display = "none";
  }

  function drawBossBar(boss) {
    if (!boss || !boss.alive) return;
    const w = ui.canvas.getBoundingClientRect().width;
    const barW = Math.min(560, w - 24);
    const x = (w - barW) / 2;
    const y = 12;
    const h = 14;

    const ratio = boss.hpMax > 0 ? Math.max(0, boss.hp / boss.hpMax) : 0;

    ctx.fillStyle = "rgba(10,14,22,.72)";
    ctx.fillRect(x - 6, y - 6, barW + 12, h + 12);
    ctx.strokeStyle = "#1f2a3a";
    ctx.strokeRect(x - 6, y - 6, barW + 12, h + 12);

    ctx.fillStyle = "#3a0b0b";
    ctx.fillRect(x, y, barW, h);
    ctx.fillStyle = boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
    ctx.fillRect(x, y, barW * ratio, h);

    ctx.fillStyle = "#e8eefc";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const shield = boss.shieldLeft > 0 ? ` SHIELD:${boss.shieldLeft.toFixed(1)}s` : "";
    ctx.fillText(`BOSS HP ${boss.hp}/${boss.hpMax}  PHASE:${boss.phase}${shield}`, x + 6, y + 11);
  }

  function drawState(g, myUid) {
    resizeCanvas();
    ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
    ui.hud.style.display = "";

    const my = (g.players || []).find(p => p.uid === myUid);
    if (my) {
      const cd = my.shootCooldown ?? 0;
      const can = cd <= 0.001;
      const colorLabel = my.color === "red" ? "RED" : "BLUE";
      ui.hudLine1.textContent = `YOU: ${colorLabel} | SCORE: ${my.score} | WAVE: ${g.wave}`;
      ui.hudLine2.textContent = can ? "発射可能" : `クールダウン: ${cd.toFixed(2)}s`;
      ui.hudLine3.textContent = `A/D移動 Space発射 | 生存: ${my.alive ? "YES" : "NO"}`;
      ui.youTag.textContent = `YOU:${colorLabel}`;
    } else {
      ui.hudLine1.textContent = `WAVE: ${g.wave} elapsed:${g.elapsed ?? "?"}`;
      ui.hudLine2.textContent = "";
      ui.hudLine3.textContent = "";
      ui.youTag.textContent = `YOU:WATCH`;
    }

    drawBossBar(g.boss);

    for (const e of (g.enemies || [])) {
      const s = toScreen(e.x, e.y);
      ctx.fillStyle =
        e.type === "A" ? "#ffd166" :
        e.type === "B" ? "#ff9f1c" :
        e.type === "C" ? "#7bdff2" :
        e.type === "E" ? "#b8f2a6" : "#ffd166";
      ctx.fillRect(s.x - 8, s.y - 8, 16, 16);
    }

    for (const h of (g.hazards || [])) {
      const s = toScreen(h.x, h.y);
      ctx.fillStyle = "#ff4d6d";
      ctx.beginPath();
      ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
      ctx.fill();
    }

    if (g.boss && g.boss.alive) {
      const s = toScreen(g.boss.x, g.boss.y);
      ctx.fillStyle = g.boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
      ctx.fillRect(s.x - 26, s.y - 14, 52, 28);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(s.x - 26, s.y - 14, 52, 28);
    }

    for (const p of (g.players || [])) {
      const s = toScreen(p.x, p.y);
      const col = p.color === "red" ? "#ff3b3b" : "#2b78ff";
      ctx.fillStyle = col;
      ctx.fillRect(s.x - 12, s.y - 7, 24, 14);
      if (p.uid === myUid) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x - 14, s.y - 9, 28, 18);
      }
    }

    ctx.fillStyle = "#e8eefc";
    for (const b of (g.playerBullets || [])) {
      const s = toScreen(b.x, b.y);
      ctx.fillRect(s.x - 2, s.y - 8, 4, 16);
    }

    for (const b of (g.enemyBullets || [])) {
      const s = toScreen(b.x, b.y);
      const col =
        b.type === "C_HOMING" ? "#7bdff2" :
        (b.type || "").includes("SNIPE") ? "#ffffff" :
        (b.type || "").includes("WAVE") ? "#b4f8c8" :
        (b.type || "").includes("SPLIT") ? "#ffd6ff" :
        "#ffccff";
      ctx.fillStyle = col;
      ctx.fillRect(s.x - 3, s.y - 3, 6, 6);
    }
  }

  // ---------------- Input sender (per room) ----------------
  function bindInputSenderForRoom(uid, roomId, getIsPlayerFn) {
    const keys = { left:false, right:false, shoot:false };
    let bound = true;

    window.addEventListener("keydown", (e) => {
      if (!bound) return;
      if (e.code === "KeyA") keys.left = true;
      if (e.code === "KeyD") keys.right = true;
      if (e.code === "Space") { keys.shoot = true; e.preventDefault(); }
    });
    window.addEventListener("keyup", (e) => {
      if (!bound) return;
      if (e.code === "KeyA") keys.left = false;
      if (e.code === "KeyD") keys.right = false;
      if (e.code === "Space") { keys.shoot = false; e.preventDefault(); }
    });

    const timer = setInterval(() => {
      if (!bound) return;
      if (!roomId) return;
      if (!getIsPlayerFn()) return;
      set(ref(db, PATHS.roomInputs(roomId, uid)), { ...keys, t: Date.now() });
    }, 50);

    return () => { bound = false; clearInterval(timer); };
  }

  // ---------------- Game simulation (same as before, room-scoped) ----------------
  const WAVE_DUR = [30, 40, 90, 140];
  const SHOOT_CD = 3.0;
  const SCORE = { A: 60, B: 120, C: 200, D: 0, E: 300, BOSS_HIT: 10, BOSS_KILL: 5000 };
  const ENEMY = {
    A: { firePerSec: 0.12, bulletSpeed: 0.28, moveSpeed: 0.06 },
    B: { firePerSec: 0.18, bulletSpeed: 0.32, moveSpeed: 0.09 },
    C: { firePerSec: 0.14, bulletSpeed: 0.26, moveSpeed: 0.06, homingTime: 0.7, turnRate: 2.2 },
    E: { firePerSec: 0.45, bulletSpeed: 0.36 },
    D: { fallSpeed: 0.10 }
  };
  const BOSS = {
    hpMax: 40,
    x: 0.5,
    y: 0.16,
    baseBulletSpeed: 0.33,
    shieldEvery: 9.0,
    shieldDuration: 1.8,
    moveSpeed: 0.18
  };
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const normalizeAngle=(a)=>{while(a>Math.PI)a-=Math.PI*2;while(a<-Math.PI)a+=Math.PI*2;return a;};
  const mulberry32=(a)=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;};
  const randChoice=(rng,arr)=>arr[Math.floor(rng()*arr.length)];
  const bossPhase = (b)=> b.hp>30?1:b.hp>20?2:b.hp>10?3:4;

  function createHostSim(room) {
    const p1Uid = room.p1Uid;
    const p2Uid = room.p2Uid;

    const rng = mulberry32((Date.now() ^ 0x9e3779b9) >>> 0);

    const st = {
      tick: 0,
      mode: room.mode,
      elapsed: 0,
      wave: 1,

      formation: { dir: 1, xOffset: 0, yOffset: 0, speedBase: 0.10, stepDown: 0.03 },

      players: {},
      enemies: [],
      hazards: [],
      playerBullets: [],
      enemyBullets: [],
      boss: null,

      _hazAcc: 0,
      _eAcc: 0,
      _bossRespawnAcc: 0,
      nextEnemyId: 1,
      nextHazardId: 1,

      rng
    };

    const mkPlayer = (uid, color, x) => ({ uid, color, x, y: 0.9, alive: true, score: 0, shootCooldown: 0 });
    st.players[p1Uid] = mkPlayer(p1Uid, "blue", 0.45);
    if (p2Uid) st.players[p2Uid] = mkPlayer(p2Uid, "red", 0.55);

    let lastInputs = {};
    const applyInputs = (inputs) => { lastInputs = inputs || {}; };

    function spawnFormation(types) {
      const rows=3, cols=6, x0=0.18, y0=0.14, dx=0.11, dy=0.085;
      for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
        const type = randChoice(st.rng, types);
        st.enemies.push({ id:`en_${st.nextEnemyId++}`, type, baseX:x0+c*dx, baseY:y0+r*dy, x:x0+c*dx, y:y0+r*dy, alive:true, fireAcc:0 });
      }
    }

    function spawnBoss() {
      st.boss = {
        alive:true,
        x:BOSS.x, y:BOSS.y,
        hp:BOSS.hpMax, hpMax:BOSS.hpMax,
        time:0, attackAcc:0,
        shieldAcc:0, shieldLeft:0,
        feintQueue:[],
        dashLeft:0, dashDir:1,
      };
    }

    function spawnWave(w) {
      st.enemies = [];
      st.hazards = [];
      st.enemyBullets = [];
      st.playerBullets = [];
      st._hazAcc = 0;
      st._eAcc = 0;

      st.formation.dir = 1; st.formation.xOffset = 0; st.formation.yOffset = 0;
      st.boss = null;

      if (w===1) spawnFormation(["A"]);
      if (w===2) spawnFormation(["A","B","C"]);
      if (w===3) spawnFormation(["B","C"]);
      if (w===4) spawnBoss();
    }
    spawnWave(1);

    function pickAlivePlayer() {
      const arr = Object.values(st.players).filter(p=>p.alive);
      if (!arr.length) return null;
      return arr[Math.floor(st.rng()*arr.length)];
    }

    function updateFormation(dt) {
      const fes = st.enemies.filter(e=>e.alive && (e.type==="A"||e.type==="B"||e.type==="C"));
      if (!fes.length) return;
      let minX=Infinity, maxX=-Infinity;
      for (const e of fes) { const x=e.baseX+st.formation.xOffset; minX=Math.min(minX,x); maxX=Math.max(maxX,x); }
      st.formation.xOffset += st.formation.dir * st.formation.speedBase * dt;
      if (maxX>0.92){ st.formation.dir=-1; st.formation.yOffset += st.formation.stepDown; }
      if (minX<0.08){ st.formation.dir= 1; st.formation.yOffset += st.formation.stepDown; }
      for (const e of fes) {
        const extra=(e.type==="B")?(ENEMY.B.moveSpeed-ENEMY.A.moveSpeed):0;
        e.x = e.baseX + st.formation.xOffset*(1+extra);
        e.y = e.baseY + st.formation.yOffset;
      }
    }

    function updateE(dt) {
      for (const e of st.enemies) {
        if (!e.alive || e.type!=="E") continue;
        e.t=(e.t??0)+dt;
        e.x = e.x0 + Math.sin(e.t*2.2)*0.10;
        e.y += 0.12*dt;
        if (e.y>1.1) e.alive=false;
      }
    }

    function updateHazards(dt) {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        h.y += ENEMY.D.fallSpeed*dt;
        if (h.y>1.1) h.alive=false;
      }
    }

    function spawnHazards(dt) {
      if (st.wave!==3) return;
      st._hazAcc += dt/8;
      if (st._hazAcc<1) return;
      st._hazAcc -= 1;
      st.hazards.push({ id:`hz_${st.nextHazardId++}`, type:"D", x:0.10+st.rng()*0.80, y:-0.05, alive:true });
    }

    function spawnEIfNeeded(dt) {
      if (st.wave!==3) return;
      st._eAcc += dt/5;
      if (st._eAcc<1) return;
      st._eAcc -= 1;
      const x0=0.15+st.rng()*0.70;
      st.enemies.push({ id:`en_${st.nextEnemyId++}`, type:"E", x0, x:x0, y:-0.06, t:0, alive:true, fireAcc:0 });
    }

    function movePlayerBullets(dt) {
      for (const b of st.playerBullets) b.y -= 0.85*dt;
      st.playerBullets = st.playerBullets.filter(b=>b.y>-0.1 && !b.dead);
    }

    function moveEnemyBullets(dt) {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;
        if (b.waveAmp) {
          b.waveT=(b.waveT??0)+dt;
          b.x += Math.sin(b.waveT*b.waveFreq)*b.waveAmp*dt;
        }
        if (b.splitAt!=null) {
          b.life=(b.life??0)+dt;
          if (!b.splitDone && b.life>=b.splitAt) {
            b.splitDone=true;
            const spd=Math.hypot(b.vx,b.vy);
            st.enemyBullets.push({ x:b.x, y:b.y, vx:-0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            st.enemyBullets.push({ x:b.x, y:b.y, vx: 0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            b.dead=true; continue;
          }
        }
        if (b.type==="C_HOMING" && b.homingLeft>0) {
          b.homingLeft-=dt;
          const t = pickAlivePlayer();
          if (t) {
            const dx=t.x-b.x, dy=t.y-b.y;
            const desired=Math.atan2(dy,dx);
            const cur=Math.atan2(b.vy,b.vx);
            const diff=normalizeAngle(desired-cur);
            const maxTurn=2.2*dt;
            const turned=cur+clamp(diff,-maxTurn,maxTurn);
            const spd=Math.hypot(b.vx,b.vy);
            b.vx=Math.cos(turned)*spd;
            b.vy=Math.sin(turned)*spd;
          }
        }
        b.x += b.vx*dt;
        b.y += b.vy*dt;
        if (b.y>1.2 || b.x<-0.2 || b.x>1.2) b.dead=true;
      }
      st.enemyBullets = st.enemyBullets.filter(b=>!b.dead);
    }

    function enemyFire(dt) {
      const alivePlayers = Object.values(st.players).filter(p=>p.alive);
      if (!alivePlayers.length) return;
      for (const e of st.enemies) {
        if (!e.alive) continue;
        if (!(e.type==="A"||e.type==="B"||e.type==="C"||e.type==="E")) continue;
        const cfg = ENEMY[e.type];
        e.fireAcc=(e.fireAcc??0)+cfg.firePerSec*dt;
        while (e.fireAcc>=1) {
          e.fireAcc-=1;
          if (e.type==="C") {
            const t=pickAlivePlayer(); if(!t) break;
            const dx=t.x-e.x, dy=t.y-e.y;
            const ang=Math.atan2(dy,dx);
            const spd=cfg.bulletSpeed;
            st.enemyBullets.push({ x:e.x,y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, type:"C_HOMING", homingLeft:cfg.homingTime, dead:false });
          } else {
            const t=pickAlivePlayer();
            const aim=t?clamp((t.x-e.x)*1.2,-0.25,0.25):0;
            st.enemyBullets.push({ x:e.x,y:e.y, vx:aim, vy:cfg.bulletSpeed, type:`${e.type}_SHOT`, dead:false });
          }
        }
      }
    }

    function collidePlayerBulletsToEnemies() {
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        for (const e of st.enemies) {
          if (!e.alive) continue;
          const dx=e.x-b.x, dy=e.y-b.y;
          if (dx*dx+dy*dy<0.00085) {
            e.alive=false; b.dead=true;
            const p=st.players[b.ownerUid]; if (p) p.score += (SCORE[e.type]??0);
            break;
          }
        }
      }
      st.enemies = st.enemies.filter(e=>e.alive);
    }

    function collideHazardsToPlayers() {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        for (const uid in st.players) {
          const p=st.players[uid]; if(!p.alive) continue;
          const dx=p.x-h.x, dy=p.y-h.y;
          if (dx*dx+dy*dy<0.0016) { p.alive=false; h.alive=false; break; }
        }
      }
      st.hazards = st.hazards.filter(h=>h.alive);
    }

    function collideEnemyBulletsToPlayers() {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;
        for (const uid in st.players) {
          const p=st.players[uid]; if(!p.alive) continue;
          const dx=p.x-b.x, dy=p.y-b.y;
          if (dx*dx+dy*dy<0.0010) { p.alive=false; b.dead=true; break; }
        }
      }
    }

    // boss patterns
    function doBossAttack(phase, enrage) {
      const patterns = [pRing, pRightSide];
      if (phase>=2) patterns.push(pSnipe, pSplit);
      if (phase>=3) patterns.push(pWave, pHomingWeak, pFeint);
      if (phase>=4) patterns.push(pDash, pSnake);
      const p = randChoice(st.rng, patterns);
      p(enrage);
    }
    function pRing(enrage) {
      const boss=st.boss;
      const phase=bossPhase(boss);
      const n = phase===1?10:phase===2?12:phase===3?14:16;
      const spd=BOSS.baseBulletSpeed*(1+0.08*(phase-1))*enrage;
      for (let i=0;i<n;i++){
        const a=Math.PI*2*(i/n);
        st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_RING", dead:false });
      }
    }
    function pRightSide(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.05*enrage;
      const n=8;
      for (let i=0;i<n;i++){
        const a=(-Math.PI/2)+(i/(n-1))*(Math.PI/2);
        const vx=Math.cos(a)*spd+0.18;
        const vy=Math.sin(a)*spd+0.45;
        st.enemyBullets.push({ x:boss.x,y:boss.y, vx,vy, type:"BOSS_RIGHT", dead:false });
      }
    }
    function pWave(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*enrage;
      const n=6;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.03;
        st.enemyBullets.push({ x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.22, waveFreq:7.0, type:"BOSS_WAVE", dead:false });
      }
    }
    function pFeint(enrage) {
      const boss=st.boss;
      const delay=0.55+(st.rng()*0.45);
      boss.feintQueue.push({
        t: delay,
        pattern: () => {
          const spd=BOSS.baseBulletSpeed*0.95*enrage;
          const n=8;
          for (let i=0;i<n;i++){
            const a=Math.PI*2*(i/n);
            st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_FEINT", dead:false });
          }
        }
      });
    }
    function pSnipe(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      boss.feintQueue.push({
        t: 0.65,
        pattern: () => {
          const dx=target.x-boss.x, dy=target.y-boss.y;
          const a=Math.atan2(dy,dx);
          const spd=BOSS.baseBulletSpeed*1.9*enrage;
          st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_SNIPE", dead:false });
        }
      });
    }
    function pSplit(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.1*enrage;
      st.enemyBullets.push({ x:boss.x,y:boss.y, vx:0, vy:spd, splitAt:0.55, splitDone:false, type:"BOSS_SPLIT", dead:false });
    }
    function pHomingWeak(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      const dx=target.x-boss.x, dy=target.y-boss.y;
      const a=Math.atan2(dy,dx);
      const spd=BOSS.baseBulletSpeed*1.05*enrage;
      st.enemyBullets.push({ x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"C_HOMING", homingLeft:0.75, dead:false });
    }
    function pDash(enrage) {
      const boss=st.boss;
      boss.dashLeft = 0.8*Math.min(1.4,enrage);
      boss.dashDir = (st.rng()<0.5) ? -1 : 1;
    }
    function pSnake(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*0.95*enrage;
      const n=4;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.05;
        st.enemyBullets.push({ x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.30, waveFreq:9.5, type:"BOSS_SNAKE", dead:false });
      }
    }

    function updateBoss(dt, wave4Elapsed) {
      const boss = st.boss;
      if (!boss || !boss.alive) return;

      boss.time += dt;
      const over = Math.max(0, wave4Elapsed - WAVE_DUR[3]);
      const enrage = 1 + over * 0.012;

      if (boss.dashLeft>0) {
        boss.dashLeft -= dt;
        boss.x += boss.dashDir*(BOSS.moveSpeed*3.2)*dt;
        if (boss.x<0.12){ boss.x=0.12; boss.dashDir=1; }
        if (boss.x>0.88){ boss.x=0.88; boss.dashDir=-1; }
      } else {
        boss.x += Math.sin(boss.time*0.9)*0.06*dt;
        boss.x = clamp(boss.x,0.12,0.88);
      }

      boss.shieldAcc += dt;
      if (boss.shieldLeft>0) boss.shieldLeft -= dt;
      if (boss.shieldAcc >= BOSS.shieldEvery) {
        boss.shieldAcc = 0;
        boss.shieldLeft = BOSS.shieldDuration;
      }

      for (const f of boss.feintQueue) f.t -= dt;
      while (boss.feintQueue.length && boss.feintQueue[0].t <= 0) {
        const fire = boss.feintQueue.shift();
        if (fire) fire.pattern();
      }

      const phase = bossPhase(boss);
      const baseAttacksPerSec = phase===1?0.55:phase===2?0.75:phase===3?0.95:1.20;
      boss.attackAcc += baseAttacksPerSec * Math.min(2.2,enrage) * dt;
      while (boss.attackAcc >= 1) { boss.attackAcc -= 1; doBossAttack(phase, Math.min(2.2,enrage)); }
    }

    function collidePlayerBulletsToBoss() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        const dx=boss.x-b.x, dy=boss.y-b.y;
        if (dx*dx+dy*dy<0.0032) {
          b.dead = true;
          if (boss.shieldLeft>0) continue;
          boss.hp -= 1;
          const p=st.players[b.ownerUid]; if (p) p.score += SCORE.BOSS_HIT;
          if (boss.hp<=0) {
            const p2=st.players[b.ownerUid]; if (p2) p2.score += SCORE.BOSS_KILL;
            boss.alive = false;
          }
        }
      }
    }

    function collideBossToPlayers() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const uid in st.players) {
        const p=st.players[uid]; if(!p.alive) continue;
        const dx=p.x-boss.x, dy=p.y-boss.y;
        if (dx*dx+dy*dy<0.0040) p.alive=false;
      }
    }

    function isAllDead() {
      return Object.values(st.players).every(p=>!p.alive);
    }

    function step(dt) {
      st.tick++;
      st.elapsed += dt;

      const t = st.elapsed;
      const tW1=WAVE_DUR[0], tW2=tW1+WAVE_DUR[1], tW3=tW2+WAVE_DUR[2];

      let newWave = st.wave;
      if (t < tW1) newWave=1;
      else if (t < tW2) newWave=2;
      else if (t < tW3) newWave=3;
      else newWave=4;

      if (newWave !== st.wave) { st.wave = newWave; spawnWave(newWave); }

      // players
      for (const uid in st.players) {
        const p=st.players[uid];
        if (!p.alive) continue;
        const inp = lastInputs?.[uid] || {};
        const speed=0.45;
        if (inp.left) p.x -= speed*dt;
        if (inp.right) p.x += speed*dt;
        p.x = clamp(p.x, 0.05, 0.95);

        p.shootCooldown = Math.max(0, p.shootCooldown - dt);
        if (inp.shoot && p.shootCooldown===0) {
          st.playerBullets.push({ x:p.x, y:p.y-0.03, ownerUid:uid });
          p.shootCooldown = SHOOT_CD;
        }
      }

      if (st.wave<=3) {
        updateFormation(dt);
        updateE(dt);
        updateHazards(dt);
        enemyFire(dt);
        spawnHazards(dt);
        spawnEIfNeeded(dt);

        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideHazardsToPlayers();
        collidePlayerBulletsToEnemies();
      } else {
        const wave4Elapsed = Math.max(0, st.elapsed - tW3);

        // 全員死ぬまで終わらない：ボスは倒されても復活
        if ((!st.boss || !st.boss.alive) && !isAllDead()) {
          st._bossRespawnAcc += dt;
          if (st._bossRespawnAcc >= 3.0) { st._bossRespawnAcc = 0; spawnBoss(); }
        } else {
          st._bossRespawnAcc = 0;
        }

        updateBoss(dt, wave4Elapsed);
        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideBossToPlayers();
        collidePlayerBulletsToBoss();
      }

      movePlayerBullets(dt);
      st.playerBullets = st.playerBullets.filter(b=>!b.dead);
    }

    function snapshot() {
      const playersArr = Object.values(st.players).map(p=>({ uid:p.uid, x:p.x, y:p.y, alive:p.alive, score:p.score, color:p.color, shootCooldown:p.shootCooldown }));
      const boss = st.boss ? {
        x:st.boss.x, y:st.boss.y, alive:st.boss.alive,
        hp:st.boss.hp, hpMax:st.boss.hpMax,
        shieldLeft:st.boss.shieldLeft,
        phase: bossPhase(st.boss),
      } : null;

      return {
        tick: st.tick,
        mode: st.mode,
        wave: st.wave,
        elapsed: Math.floor(st.elapsed*1000)/1000,
        players: playersArr,
        enemies: st.enemies.filter(e=>e.alive).map(e=>({x:e.x,y:e.y,type:e.type})),
        hazards: st.hazards.filter(h=>h.alive).map(h=>({x:h.x,y:h.y,type:h.type})),
        playerBullets: st.playerBullets.filter(b=>!b.dead).map(b=>({x:b.x,y:b.y,ownerUid:b.ownerUid})),
        enemyBullets: st.enemyBullets.filter(b=>!b.dead).map(b=>({x:b.x,y:b.y,type:b.type})),
        boss,
        sentAt: Date.now()
      };
    }

    return { step, snapshot, applyInputs, isAllDead };
  }

  // ---------------- Room lifecycle ----------------
  // room: { roomId, state, mode, hostUid, p1Uid, p2Uid, recruiting, ready, createdAt, updatedAt }
  // state: idle|recruiting|preparing|playing|finished
  const MAX_ROOMS = 5;

  let uid = null;
  let myName = "";
  let currentRoomId = null;
  let currentRoomUnsub = null;
  let currentGameUnsub = null;
  let stopInputSender = null;

  async function countRooms() {
    const snap = await get(ref(db, PATHS.roomsIndex));
    const v = snap.val() || {};
    return Object.keys(v).length;
  }

  function roomStateLabel(st) {
    if (st === "recruiting") return "募集中";
    if (st === "preparing") return "準備中";
    if (st === "playing") return "プレイ中";
    if (st === "finished") return "終了処理";
    return "待機";
  }

  function canJoinAsPlayer(room) {
    if (!room) return false;
    if (room.state !== "recruiting" && room.state !== "preparing") return false;
    if (room.mode !== "multi") return false;
    return !room.p2Uid; // empty slot
  }

  function isPlayer(room) {
    return room?.p1Uid === uid || room?.p2Uid === uid;
  }

  function myColor(room) {
    if (!room) return null;
    if (room.p1Uid === uid) return "BLUE";
    if (room.p2Uid === uid) return "RED";
    return null;
  }

  async function createRoom(mode) {
    const roomsCount = await countRooms();
    if (roomsCount >= MAX_ROOMS) {
      ui.createHint.textContent = "部屋数が上限（5）です。誰かが部屋を削除してから作成してください。";
      return;
    }
    const roomId = `room_${Date.now()}_${uuidShort()}`;
    const room = {
      roomId,
      state: (mode === "multi") ? "recruiting" : "preparing",
      mode,
      hostUid: uid,
      hostName: myName,
      p1Uid: uid,
      p2Uid: null,
      recruiting: mode === "multi" ? { joinerUid: null } : null,
      ready: { [uid]: false },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    await set(ref(db, PATHS.room(roomId)), room);
    await set(ref(db, PATHS.roomIndex(roomId)), { roomId, state: room.state, mode, hostName: myName, createdAt: Date.now() });
    await enterRoom(roomId, "player");
  }

  async function deleteRoom(roomId) {
    await remove(ref(db, PATHS.room(roomId)));
    await remove(ref(db, PATHS.roomIndex(roomId)));
  }

  async function enterRoom(roomId, as = "watch") {
    // clean old
    await leaveRoom(false);

    currentRoomId = roomId;
    ui.roomTag.style.display = "";
    ui.roomTag.textContent = `room:${roomId.slice(-6)}`;
    setScreen("game");

    // input sender bound to room
    stopInputSender = bindInputSenderForRoom(uid, roomId, () => {
      const room = lastRoomCache;
      return room?.state === "playing" && isPlayer(room);
    });

    subscribeRoom(roomId);
  }

  async function leaveRoom(goLobby = true) {
    if (stopInputSender) { stopInputSender(); stopInputSender = null; }

    if (currentRoomUnsub) { currentRoomUnsub(); currentRoomUnsub = null; }
    if (currentGameUnsub) { currentGameUnsub(); currentGameUnsub = null; }

    currentRoomId = null;
    ui.roomTag.style.display = "none";
    ui.roomTag.textContent = "room:-";

    ui.readyBtn.style.display = "none";
    ui.retireBtn.style.display = "none";

    if (goLobby) setScreen("lobby");
  }

  // ---------------- Room subscriptions ----------------
  let lastRoomCache = null;
  let hostLoopTimer = null;

  function subscribeRoom(roomId) {
    const roomRef = ref(db, PATHS.room(roomId));
    const gameRef = ref(db, PATHS.roomGame(roomId));

    currentRoomUnsub = onValue(roomRef, async (snap) => {
      const room = snap.val();
      lastRoomCache = room;

      if (!room) {
        // room deleted
        drawIdle("部屋が削除されました");
        await leaveRoom(true);
        return;
      }

      ui.modeTag.textContent = `mode:${room.mode}`;
      ui.stateTag.textContent = `state:${room.state}`;
      ui.statusLine.textContent = `in ${roomId.slice(-6)} ${room.state}`;

      const player = isPlayer(room);
      const host = room.hostUid === uid;
      ui.retireBtn.style.display = (host && room.state === "playing") ? "" : "none";
      ui.readyBtn.style.display = (player && room.state === "preparing") ? "" : "none";

      // preparing/recruiting prompt (multi)
      if (room.state === "recruiting" && room.mode === "multi") {
        if (!player && !room.recruiting?.joinerUid && !room.p2Uid) {
          // show prompt once per room open (simple: confirm modal)
          const ok = await modalAsk("この部屋のマルチに参加しますか？", "最初にOKした1人だけ参加できます");
          if (!ok) return;

          // transaction to claim joiner
          const joinerRef = ref(db, PATHS.roomRecruitJoiner(roomId));
          const tx = await runTransaction(joinerRef, (cur) => (cur ? undefined : uid));
          if (!tx.committed) {
            showAnn("間に合いませんでした", "他の人が先に参加しました");
            setTimeout(hideAnn, 1200);
            return;
          }

          // set p2
          const now = (await get(roomRef)).val();
          if (!now || now.state !== "recruiting") return;

          await update(roomRef, {
            state: "preparing",
            p2Uid: uid,
            ready: { ...(now.ready||{}), [uid]: false },
            updatedAt: Date.now(),
          });
          await update(ref(db, PATHS.roomIndex(roomId)), { state: "preparing" });
        }
      }

      // auto cleanup if host/p1/p2 offline and room is stuck
      await maybeRoomAutoCleanup(roomId, room);

      // host loop
      await startHostLoopIfNeeded(roomId, room);

      // finished -> delete automatically (admin skip score; here we keep it simple: always delete after a short delay)
      if (room.state === "finished") {
        showAnn("ゲーム終了", `理由: ${room.finishedReason || "?"}\n部屋を閉じます…`);
        // delete room after 2 sec
        setTimeout(async () => {
          await deleteRoom(roomId);
          hideAnn();
          await leaveRoom(true);
        }, 2000);
      }
    });

    currentGameUnsub = onValue(gameRef, (snap) => {
      const g = snap.val();
      if (!g) {
        drawIdle("準備中 / 観戦待機中");
        return;
      }
      drawState(g, uid);
    });
  }

  async function maybeRoomAutoCleanup(roomId, room) {
    // if nobody important online, delete room
    const hostOn = await isOnline(room.hostUid);
    const p1On = await isOnline(room.p1Uid);
    const p2On = room.p2Uid ? await isOnline(room.p2Uid) : false;
    const anyOn = hostOn || p1On || p2On;

    if (!anyOn) {
      await deleteRoom(roomId);
      return;
    }

    // playing but game stale => finish
    if (room.state === "playing") {
      const g = (await get(ref(db, PATHS.roomGame(roomId)))).val();
      const tooOld = !g?.sentAt || (Date.now() - g.sentAt) > 15000;
      if (tooOld) {
        await update(ref(db, PATHS.room(roomId)), { state: "finished", finishedReason: "stale_game", updatedAt: Date.now() });
        await update(ref(db, PATHS.roomIndex(roomId)), { state: "finished" });
      }
    }
  }

  // ---------------- Host loop per room ----------------
  const activeHostLoops = new Map(); // roomId -> {running, timer}

  async function startHostLoopIfNeeded(roomId, room) {
    const isHost = room.hostUid === uid;
    const isPlaying = room.state === "playing";

    const key = roomId;
    const cur = activeHostLoops.get(key);

    if (cur?.running) {
      if (!isHost || !isPlaying) {
        clearInterval(cur.timer);
        activeHostLoops.delete(key);
      }
      return;
    }

    if (!isHost || !isPlaying) return;

    const sim = createHostSim(room);
    await set(ref(db, PATHS.roomGame(roomId)), sim.snapshot());

    const hz = 15;
    const intervalMs = Math.floor(1000 / hz);

    const timer = setInterval(async () => {
      const roomNow = (await get(ref(db, PATHS.room(roomId)))).val();
      if (!roomNow || roomNow.state !== "playing") return;

      const inputs = (await get(ref(db, `rooms/${roomId}/inputs`))).val() || {};
      // idle timeout: both players idle
      const now = Date.now();
      const uids = [roomNow.p1Uid, roomNow.p2Uid].filter(Boolean);
      const lastTimes = uids.map(u => inputs?.[u]?.t ?? 0);
      const allIdle = uids.length > 0 && lastTimes.every(t => (now - t) >= 60000);
      if (allIdle) {
        await update(ref(db, PATHS.room(roomId)), { state: "finished", finishedReason: "idle_timeout", updatedAt: Date.now() });
        await update(ref(db, PATHS.roomIndex(roomId)), { state: "finished" });
        return;
      }

      sim.applyInputs(inputs);
      sim.step(intervalMs / 1000);

      if (sim.isAllDead()) {
        await update(ref(db, PATHS.room(roomId)), { state: "finished", finishedReason: "all_dead", updatedAt: Date.now() });
        await update(ref(db, PATHS.roomIndex(roomId)), { state: "finished" });
        return;
      }

      await set(ref(db, PATHS.roomGame(roomId)), sim.snapshot());
    }, intervalMs);

    activeHostLoops.set(key, { running: true, timer });
  }

  // ---------------- Rooms list (lobby) ----------------
  function bindRoomsList() {
    onValue(ref(db, PATHS.roomsIndex), (snap) => {
      const rooms = snap.val() || {};
      const entries = Object.values(rooms).sort((a,b) => (b.createdAt||0)-(a.createdAt||0));

      ui.roomsList.innerHTML = "";
      if (entries.length === 0) {
        ui.roomsList.innerHTML = `<div class="muted">部屋がありません。左から作成してください。</div>`;
        return;
      }

      for (const r of entries) {
        const div = document.createElement("div");
        div.className = "roomRow";

        const left = document.createElement("div");
        const top = document.createElement("div");
        top.className = "roomTop";
        top.innerHTML = `
          <span class="tag">#${r.roomId.slice(-6)}</span>
          <span class="tag">${r.mode || "-"}</span>
          <span class="tag">${roomStateLabel(r.state || "idle")}</span>
          <span class="muted">host: ${escapeHtml(r.hostName || "?")}</span>
        `;
        const meta = document.createElement("div");
        meta.className = "roomMeta";
        meta.textContent = `作成: ${new Date(r.createdAt || Date.now()).toLocaleTimeString()}`;

        left.appendChild(top);
        left.appendChild(meta);

        const btns = document.createElement("div");
        btns.className = "roomBtns";

        const joinBtn = document.createElement("button");
        joinBtn.className = "secondary small";
        joinBtn.textContent = "参加/入室";
        joinBtn.onclick = async () => {
          // enter room; if not player, you'll get prompt in recruiting (multi) or just watch/standby
          await enterRoom(r.roomId, "auto");
        };

        const watchBtn = document.createElement("button");
        watchBtn.className = "ghost small";
        watchBtn.textContent = "観戦";
        watchBtn.onclick = async () => {
          await enterRoom(r.roomId, "watch");
        };

        btns.appendChild(joinBtn);
        btns.appendChild(watchBtn);

        if (adminMode) {
          const adminKill = document.createElement("button");
          adminKill.className = "danger small";
          adminKill.textContent = "運営:強制終了";
          adminKill.onclick = async () => {
            await update(ref(db, PATHS.room(r.roomId)), { state: "finished", finishedReason: "admin_kill", updatedAt: Date.now() }).catch(()=>{});
            await update(ref(db, PATHS.roomIndex(r.roomId)), { state: "finished" }).catch(()=>{});
          };

          const adminReset = document.createElement("button");
          adminReset.className = "danger small";
          adminReset.textContent = "運営:強制リセット";
          adminReset.onclick = async () => {
            await deleteRoom(r.roomId);
          };

          btns.appendChild(adminKill);
          btns.appendChild(adminReset);
        }

        div.appendChild(left);
        div.appendChild(btns);

        ui.roomsList.appendChild(div);
      }
    });
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }

  // ---------------- Main ----------------
  await signInAnonymously(auth);

  onAuthStateChanged(auth, async (user) => {
    if (!user) return;
    uid = user.uid;
    ui.me.textContent = `uid: ${uid.slice(0, 8)}…`;

    await bindPresence(uid);
    bindLeaderboard();
    bindRoomsList();

    // name decide screen
    myName = await getMyName(uid);
    if (!myName) {
      setScreen("name");
      ui.nameHint.textContent = "名前を入力して決定してください";
    } else {
      ui.myNameLabel.textContent = `名前: ${myName}`;
      setScreen("lobby");
    }

    ui.saveNameBtn.onclick = async () => {
      const v = ui.nameInput.value.trim().slice(0,20);
      if (!v) { ui.nameHint.textContent = "名前を入力してください"; return; }
      await setMyName(uid, v);
      myName = v;
      ui.myNameLabel.textContent = `名前: ${myName}`;
      setScreen("lobby");
    };

    ui.changeNameBtn.onclick = () => {
      setScreen("name");
      ui.nameHint.textContent = "名前を変更して決定してください";
    };

    ui.createSoloBtn.onclick = async () => {
      await createRoom("solo");
    };
    ui.createMultiBtn.onclick = async () => {
      await createRoom("multi");
    };

    ui.leaveRoomBtn.onclick = async () => {
      await leaveRoom(true);
    };

    ui.readyBtn.onclick = async () => {
      if (!currentRoomId) return;
      await set(ref(db, PATHS.roomReady(currentRoomId, uid)), true);

      const roomRef = ref(db, PATHS.room(currentRoomId));
      const room = (await get(roomRef)).val();
      if (!room || room.hostUid !== uid) return;
      if (room.state !== "preparing") return;

      const ready = room.ready || {};
      const ok1 = !!ready?.[room.p1Uid];
      const ok2 = (room.mode === "solo") ? true : !!ready?.[room.p2Uid];

      if (ok1 && ok2) {
        await update(roomRef, { state: "playing", updatedAt: Date.now() });
        await update(ref(db, PATHS.roomIndex(currentRoomId)), { state: "playing" });
      }
    };

    ui.retireBtn.onclick = async () => {
      if (!currentRoomId) return;
      const roomRef = ref(db, PATHS.room(currentRoomId));
      const room = (await get(roomRef)).val();
      if (!room || room.hostUid !== uid) return;
      await update(roomRef, { state: "finished", finishedReason: "retire", updatedAt: Date.now() });
      await update(ref(db, PATHS.roomIndex(currentRoomId)), { state: "finished" });
    };
  });
</script>
</body>
</html>
