<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Invader あｓｄRooms (RTDB) - Solo Only + Host Lock + Wave Banner + Balance Update</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#05070b; color:#e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; overflow:hidden; }

    #app { display:grid; grid-template-rows:auto 1fr; height:100%; }
    header {
      padding:10px 12px; display:flex; gap:12px; align-items:center;
      border-bottom:1px solid rgba(31,42,58,.85);
      background: linear-gradient(180deg, rgba(10,14,22,.85), rgba(10,14,22,.60));
      backdrop-filter: blur(8px);
    }
    header b { font-weight: 900; letter-spacing:.4px; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#a8b3c7; }
    .tag { padding:2px 8px; border-radius: 999px; border:1px solid rgba(31,42,58,.85); background: rgba(11,18,32,.65); color:#a8b3c7; font-size:12px; }
    #statusLine { margin-left:auto; color:#a8b3c7; }

    button { background:#2b69ff; color:white; border:0; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800; }
    button.secondary { background:#223047; }
    button.danger { background:#b42318; }
    button.ghost { background:transparent; border:1px solid rgba(31,42,58,.85); color:#a8b3c7; }
    button.small { padding:6px 10px; border-radius:10px; font-weight:700; font-size:12px; }
    button[disabled] { opacity:.45; cursor:not-allowed; }

    input { width: 100%; box-sizing:border-box; padding:12px 12px; border-radius:12px; border:1px solid rgba(38,52,74,.9); background: rgba(11,18,32,.85); color:#e8eefc; font-size:16px; }
    .muted { color:#a8b3c7; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:12px; }

    .card {
      border:1px solid rgba(31,42,58,.85);
      border-radius:16px;
      padding:14px;
      background: rgba(14,20,32,.55);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    .screen { display:none; height:100%; }
    .screen.active { display:block; }

    #bg {
      position: fixed; inset: 0; z-index: -2;
      background:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.10), transparent 45%),
        radial-gradient(circle at 70% 30%, rgba(255,255,255,.08), transparent 45%),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.06), transparent 45%),
        linear-gradient(#070a10, #05070b);
    }
    #scanlines{
      position: fixed; inset: 0; z-index: -1; pointer-events:none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.03) 0px,
        rgba(255,255,255,.03) 1px,
        rgba(0,0,0,0) 2px,
        rgba(0,0,0,0) 4px
      );
      mix-blend-mode: overlay;
      opacity:.25;
    }

    #nameScreen .wrap { height:100%; display:flex; align-items:center; justify-content:center; padding:18px; }
    #nameScreen .panel { width:min(520px, 92vw); }
    #nameScreen h1 { margin:0 0 6px 0; font-size: 26px; }
    #nameScreen .logo {
      font-weight: 1000; letter-spacing: 1px;
      font-size: 34px; margin-bottom: 10px;
      background: linear-gradient(90deg, #7bdff2, #ffd166, #ff3b3b);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    #lobbyMain { height:100%; box-sizing:border-box; padding:14px; display:grid; grid-template-columns: 360px 1fr 320px; gap:14px; min-height:0; }
    #roomsList { overflow:auto; max-height: calc(100vh - 190px); padding-right: 4px; }
    .roomRow {
      display:grid; grid-template-columns: 1fr auto; gap:10px;
      border:1px solid rgba(31,42,58,.9);
      border-radius:14px;
      padding:12px 12px;
      background: rgba(11,18,32,.55);
      margin-bottom:10px;
    }
    .roomTop { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .roomMeta { font-size:12px; color:#a8b3c7; margin-top:4px; }
    .roomBtns { display:flex; gap:8px; justify-content:flex-end; align-items:center; flex-wrap:wrap; }
    .pill {
      display:inline-flex; align-items:center; gap:6px;
      padding:3px 10px; border-radius: 999px;
      border:1px solid rgba(31,42,58,.85);
      background: rgba(0,0,0,.25);
      color:#a8b3c7; font-size:12px;
    }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#9fb0cc; }
    .dot.playing { background:#2bff88; }
    .dot.preparing { background:#ffd166; }
    .dot.finished { background:#ff3b3b; }

    #gameWrap { height:100%; display:flex; flex-direction:column; }
    #gameTopBar {
      padding:10px 12px; border-bottom:1px solid rgba(31,42,58,.85);
      display:flex; align-items:center; gap:10px;
      background: linear-gradient(180deg, rgba(10,14,22,.85), rgba(10,14,22,.55));
      backdrop-filter: blur(8px);
    }
    #gameTopBar .spacer { flex:1; }

    #canvasArea {
      flex: 1; min-height:0;
      display:flex; align-items:center; justify-content:center;
      background:#000;
    }
    #stage {
      position: relative;
      width: min(100vw, calc(100vh * 16 / 9));
      height: min(calc(100vw * 9 / 16), 100vh);
      background:#05070b;
      border: 1px solid rgba(31,42,58,.85);
      border-radius: 14px;
      overflow:hidden;
    }
    canvas { width:100%; height:100%; display:block; background:#05070b; }

    #hud {
      position:absolute; left:10px; top:10px;
      background: rgba(10,14,22,.70);
      border:1px solid rgba(31,42,58,.85);
      padding:10px 12px;
      border-radius:14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color:#e8eefc;
      min-width: 280px;
      font-size: 13px;
      z-index: 10;
    }
    #hud .muted { font-size: 12px; }

    #ann { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.60); z-index: 20; }
    #ann .card { width:min(560px, 92vw); }

    #waveBanner {
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 30;
      pointer-events:none;
      background: rgba(0,0,0,.35);
    }
    #waveBanner .inner {
      padding: 18px 22px;
      border-radius: 18px;
      border: 1px solid rgba(31,42,58,.85);
      background: rgba(10,14,22,.72);
      backdrop-filter: blur(8px);
      text-align:center;
      min-width: min(520px, 90vw);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    #waveBanner .title {
      font-weight: 1000;
      letter-spacing: .8px;
      font-size: 34px;
      margin-bottom: 6px;
    }
    #waveBanner .sub {
      color:#a8b3c7;
      font-size: 14px;
    }
  </style>
</head>
<body>
<div id="bg"></div>
<div id="scanlines"></div>

<div id="app">
  <header>
    <b>Invader Rooms</b>
    <small class="mono" id="me"></small>
    <span class="tag" id="adminTag" style="display:none;">ADMIN</span>
    <span class="tag" id="roomTag" style="display:none;">room:-</span>
    <div id="statusLine"></div>
  </header>

  <section id="nameScreen" class="screen active">
    <div class="wrap">
      <div class="panel card">
        <div class="logo">INVADER</div>
        <h1>名前を入力</h1>
        <p class="muted" style="margin:0 0 12px 0;">最初に1回だけ必要です（後で変更可）。</p>
        <input id="nameInput" placeholder="表示名（20文字まで）" maxlength="20" />
        <div class="row" style="margin-top:12px; justify-content:flex-end;">
          <button id="saveNameBtn">決定</button>
        </div>
        <div class="muted" id="nameHint" style="margin-top:10px;"></div>
      </div>
    </div>
  </section>

  <section id="lobbyScreen" class="screen">
    <div id="lobbyMain">
      <div class="col">
        <div class="card">
          <div style="font-weight:1000; font-size:18px; letter-spacing:.4px;">ロビー</div>
          <div class="muted" style="margin-top:8px; line-height:1.6;">
            操作：<b>A/D</b> 移動、<b>Space</b> 連射（CDなし）<br/>
            Wave：30/40/90/140秒（以降ボス継続・激化）<br/>
            ソロ専用
          </div>

          <div class="row" style="margin-top:12px;">
            <button id="createSoloBtn">ソロ部屋</button>
          </div>
          <div class="muted" id="createHint" style="margin-top:10px;"></div>

          <div class="row" style="margin-top:14px; justify-content:space-between;">
            <button id="changeNameBtn" class="ghost">名前を変更</button>
            <span class="muted" id="myNameLabel"></span>
          </div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div class="muted" style="font-weight:900;">運営</div>
            <div class="tag muted">pw 1122</div>
          </div>
          <div class="row" style="margin-top:10px;">
            <input id="adminPw" placeholder="1122" inputmode="numeric" maxlength="8" style="width:120px; padding:8px 10px; font-size:13px;" />
            <button id="adminEnterBtn" class="secondary small">決定</button>
            <button id="adminExitBtn" class="ghost small" style="display:none;">解除</button>
          </div>
          <div class="muted" style="margin-top:8px; font-size:12px;">
            運営はこの端末だけ（ローカル）で有効になります。
          </div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div style="font-weight:1000; font-size:18px;">部屋一覧</div>
            <span class="tag">最大5</span>
          </div>
          <div class="muted" style="margin-top:6px;">
            ソロ専用（マルチ機能は削除済み）
          </div>
          <div id="roomsList" style="margin-top:12px;"></div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <div class="row" style="justify-content:space-between;">
            <div class="muted" style="font-weight:1000;">ランキング（上位）</div>
            <span class="tag">Realtime</span>
          </div>
          <div id="leaderboard" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </section>

  <section id="gameScreen" class="screen">
    <div id="gameWrap">
      <div id="gameTopBar">
        <span class="tag" id="screenTitle">GAME</span>
        <span class="tag" id="youTag">YOU:-</span>
        <span class="tag" id="modeTag">mode:-</span>
        <span class="tag" id="stateTag">state:-</span>
        <div class="spacer"></div>
        <button id="readyBtn" class="secondary" style="display:none;">準備完了</button>
        <button id="retireBtn" class="danger" style="display:none;">リタイア（ホスト）</button>
        <button id="leaveRoomBtn" class="secondary">部屋を出る</button>
      </div>

      <div id="canvasArea">
        <div id="stage">
          <canvas id="game"></canvas>

          <div id="hud" style="display:none;">
            <div id="hudLine1"></div>
            <div id="hudLine2" style="margin-top:4px;"></div>
            <div id="hudLine3" class="muted" style="margin-top:6px;"></div>
          </div>

          <div id="waveBanner">
            <div class="inner">
              <div class="title" id="waveBannerTitle">WAVE 1/4</div>
              <div class="sub" id="waveBannerSub">5秒後に開始</div>
            </div>
          </div>

          <div id="ann">
            <div class="card">
              <div style="font-weight:1000; margin-bottom:6px;" id="annTitle"></div>
              <div class="muted" id="annBody"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getDatabase, ref, onValue, get, set, update, remove, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
    authDomain: "suisougaku-bdcc0.firebaseapp.com",
    databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com",
    projectId: "suisougaku-bdcc0",
    storageBucket: "suisougaku-bdcc0.firebasestorage.app",
    messagingSenderId: "636001978886",
    appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
    measurementId: "G-Y04PFJ9BQ6"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  const PATHS = {
    presence: (uid) => `presence/${uid}`,
    names: (uid) => `lobby/names/${uid}`,
    leaderboardTop: `leaderboard/top`,
    roomsIndex: `rooms_index`,
    room: (roomId) => `rooms/${roomId}`,
    roomIndex: (roomId) => `rooms_index/${roomId}`,
    roomGame: (roomId) => `rooms/${roomId}/game`,
    roomInputsRoot: (roomId) => `rooms/${roomId}/inputs`,
    roomInputs: (roomId, uid) => `rooms/${roomId}/inputs/${uid}`,
    roomReady: (roomId, uid) => `rooms/${roomId}/ready/${uid}`,
  };

  const $ = (q) => document.querySelector(q);
  const ui = {
    me: $("#me"),
    adminTag: $("#adminTag"),
    roomTag: $("#roomTag"),
    statusLine: $("#statusLine"),

    nameScreen: $("#nameScreen"),
    lobbyScreen: $("#lobbyScreen"),
    gameScreen: $("#gameScreen"),

    nameInput: $("#nameInput"),
    saveNameBtn: $("#saveNameBtn"),
    nameHint: $("#nameHint"),

    myNameLabel: $("#myNameLabel"),
    changeNameBtn: $("#changeNameBtn"),

    createSoloBtn: $("#createSoloBtn"),
    createHint: $("#createHint"),

    roomsList: $("#roomsList"),
    leaderboard: $("#leaderboard"),

    adminPw: $("#adminPw"),
    adminEnterBtn: $("#adminEnterBtn"),
    adminExitBtn: $("#adminExitBtn"),

    screenTitle: $("#screenTitle"),
    youTag: $("#youTag"),
    modeTag: $("#modeTag"),
    stateTag: $("#stateTag"),
    readyBtn: $("#readyBtn"),
    retireBtn: $("#retireBtn"),
    leaveRoomBtn: $("#leaveRoomBtn"),

    canvas: $("#game"),
    stage: $("#stage"),
    hud: $("#hud"),
    hudLine1: $("#hudLine1"),
    hudLine2: $("#hudLine2"),
    hudLine3: $("#hudLine3"),

    waveBanner: $("#waveBanner"),
    waveBannerTitle: $("#waveBannerTitle"),
    waveBannerSub: $("#waveBannerSub"),

    ann: $("#ann"),
    annTitle: $("#annTitle"),
    annBody: $("#annBody"),
  };

  function setScreen(name) {
    ui.nameScreen.classList.toggle("active", name === "name");
    ui.lobbyScreen.classList.toggle("active", name === "lobby");
    ui.gameScreen.classList.toggle("active", name === "game");
  }

  function uuidShort() { return Math.random().toString(16).slice(2, 10); }
  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

  function showAnn(title, body) { ui.annTitle.textContent = title; ui.annBody.textContent = body; ui.ann.style.display = "flex"; }
  function hideAnn(){ ui.ann.style.display = "none"; }

  let adminMode = (localStorage.getItem("inv_admin") === "1");
  function setAdminMode(v) {
    adminMode = v;
    localStorage.setItem("inv_admin", v ? "1" : "0");
    ui.adminTag.style.display = v ? "" : "none";
    ui.adminExitBtn.style.display = v ? "" : "none";
  }
  setAdminMode(adminMode);

  ui.adminEnterBtn.onclick = () => {
    if (ui.adminPw.value.trim() === "1122") {
      setAdminMode(true);
      ui.adminPw.value = "";
    } else alert("パスワードが違います");
  };
  ui.adminExitBtn.onclick = () => setAdminMode(false);

  async function bindPresence(userId) {
    const presRef = ref(db, PATHS.presence(userId));
    await set(presRef, { online: true, lastSeen: serverTimestamp() });
    onDisconnect(presRef).set({ online: false, lastSeen: serverTimestamp() });
  }
  async function isOnline(userId) {
    if (!userId) return false;
    const snap = await get(ref(db, PATHS.presence(userId)));
    return !!snap.val()?.online;
  }

  async function getMyName(userId) {
    const snap = await get(ref(db, PATHS.names(userId)));
    const v = snap.val();
    return (typeof v === "string" && v.trim()) ? v.trim() : "";
  }
  async function setMyName(userId, name) {
    await set(ref(db, PATHS.names(userId)), name);
  }

  function bindLeaderboard() {
    onValue(ref(db, PATHS.leaderboardTop), (snap) => {
      const data = snap.val() || [];
      ui.leaderboard.innerHTML = "";
      if (!Array.isArray(data) || data.length === 0) { ui.leaderboard.textContent = "まだ記録がありません"; return; }
      const ol = document.createElement("ol");
      ol.style.margin = "0 0 0 18px";
      for (const row of data) {
        const li = document.createElement("li");
        li.textContent = `${row.name ?? "?"} - ${row.score ?? 0}`;
        ol.appendChild(li);
      }
      ui.leaderboard.appendChild(ol);
    });
  }

  const ctx = ui.canvas.getContext("2d");
  let stageW = 0, stageH = 0, dpr = 1;

  function syncStageSizeCache() {
    const rect = ui.stage.getBoundingClientRect();
    stageW = rect.width;
    stageH = rect.height;
    dpr = window.devicePixelRatio || 1;
  }
  function resizeCanvasToStage() {
    syncStageSizeCache();
    const bw = Math.max(1, Math.floor(stageW * dpr));
    const bh = Math.max(1, Math.floor(stageH * dpr));
    if (ui.canvas.width !== bw) ui.canvas.width = bw;
    if (ui.canvas.height !== bh) ui.canvas.height = bh;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    ctx.imageSmoothingEnabled = true;
  }
  const ro = new ResizeObserver(() => resizeCanvasToStage());
  ro.observe(ui.stage);
  window.addEventListener("resize", resizeCanvasToStage);
  resizeCanvasToStage();

  function toScreen(xNorm, yNorm) { return { x: xNorm * stageW, y: yNorm * stageH }; }

  const SIZE = {
    playerW: 24 * 1.5,
    playerH: 14 * 1.5,
    enemyS: 16 * 1.5,
    bossW: 52 * 1.5,
    bossH: 28 * 1.5,
    bulletW: 4 * 1.5,
    bulletH: 16 * 1.5,
    eBulletS: 6 * 1.5,
    hazardR: 10 * 1.5,
    absorberR: 26,
  };

  function clearFull() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
    ctx.restore();
  }

  function drawBackgroundForWave(wave) {
    const g = ctx.createLinearGradient(0, 0, 0, stageH);
    if (wave === 1) { g.addColorStop(0, "#070a10"); g.addColorStop(1, "#05070b"); }
    if (wave === 2) { g.addColorStop(0, "#07121a"); g.addColorStop(1, "#05070b"); }
    if (wave === 3) { g.addColorStop(0, "#1a0712"); g.addColorStop(1, "#05070b"); }
    if (wave === 4) { g.addColorStop(0, "#12071a"); g.addColorStop(1, "#05070b"); }
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, stageW, stageH);
  }

  function drawBossBar(boss) {
    if (!boss || !boss.alive) return;
    const barW = Math.min(560, stageW - 24);
    const x = (stageW - barW) / 2;
    const y = 10;
    const h = 14;

    const ratio = boss.hpMax > 0 ? Math.max(0, boss.hp / boss.hpMax) : 0;

    ctx.fillStyle = "rgba(10,14,22,.72)";
    ctx.fillRect(x - 6, y - 6, barW + 12, h + 12);
    ctx.strokeStyle = "rgba(31,42,58,.9)";
    ctx.strokeRect(x - 6, y - 6, barW + 12, h + 12);

    ctx.fillStyle = "#3a0b0b";
    ctx.fillRect(x, y, barW, h);

    ctx.fillStyle = boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
    ctx.fillRect(x, y, barW * ratio, h);

    ctx.fillStyle = "#e8eefc";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const shield = boss.shieldLeft > 0 ? ` SHIELD:${boss.shieldLeft.toFixed(1)}s` : "";
    ctx.fillText(`BOSS HP ${boss.hp}/${boss.hpMax}  PHASE:${boss.phase}${shield}`, x + 6, y + 11);
  }

  let latestSnap = null;
  let renderState = null;
  const EMA_ALPHA = 0.18;

  let lastSeenWave = null;
  let lastSeenTick = null;
  let lastSeenSentAt = null;

  function hardResetRenderStateFromLatest() {
    if (!latestSnap) return;
    renderState = JSON.parse(JSON.stringify(latestSnap));
    lastSeenWave = latestSnap.wave ?? null;
    lastSeenTick = latestSnap.tick ?? null;
    lastSeenSentAt = latestSnap.sentAt ?? null;
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  function smoothListByIdSafe(key, alpha) {
    const nextArr = (latestSnap && Array.isArray(latestSnap[key])) ? latestSnap[key] : [];
    const allHaveId = nextArr.every(o => o && typeof o.id === "string");
    if (!allHaveId) {
      renderState[key] = nextArr.map(o => ({ ...o }));
      return;
    }

    const prevArr = (renderState && Array.isArray(renderState[key])) ? renderState[key] : [];
    const prevMap = new Map(prevArr.map(o => [o.id, o]));

    const out = [];
    for (const ne of nextArr) {
      const re = prevMap.get(ne.id);
      if (!re) out.push({ ...ne });
      else out.push({ ...ne, x: lerp(re.x ?? ne.x, ne.x, alpha), y: lerp(re.y ?? ne.y, ne.y, alpha) });
    }
    renderState[key] = out;
  }

  function smoothToward(alpha) {
    if (!latestSnap) return;
    if (!renderState) { hardResetRenderStateFromLatest(); return; }

    renderState.wave = latestSnap.wave;
    renderState.elapsed = latestSnap.elapsed;
    renderState.mode = latestSnap.mode;
    renderState.tick = latestSnap.tick;
    renderState.sentAt = latestSnap.sentAt;
    renderState.waveDelayLeft = latestSnap.waveDelayLeft;
    renderState.bossKilled = latestSnap.bossKilled;

    const pMap = new Map((renderState.players||[]).map(p => [p.uid, p]));
    renderState.players = (latestSnap.players||[]).map(np => {
      const rp = pMap.get(np.uid) || { ...np };
      rp.uid = np.uid; rp.color = np.color; rp.alive = np.alive; rp.score = np.score;
      rp.x = lerp(rp.x ?? np.x, np.x, alpha);
      rp.y = lerp(rp.y ?? np.y, np.y, alpha);
      return rp;
    });

    if (latestSnap.boss) {
      if (!renderState.boss) renderState.boss = { ...latestSnap.boss };
      renderState.boss.alive = latestSnap.boss.alive;
      renderState.boss.hp = latestSnap.boss.hp;
      renderState.boss.hpMax = latestSnap.boss.hpMax;
      renderState.boss.shieldLeft = latestSnap.boss.shieldLeft;
      renderState.boss.phase = latestSnap.boss.phase;
      renderState.boss.x = lerp(renderState.boss.x ?? latestSnap.boss.x, latestSnap.boss.x, alpha);
      renderState.boss.y = lerp(renderState.boss.y ?? latestSnap.boss.y, latestSnap.boss.y, alpha);
    } else {
      renderState.boss = null;
    }

    smoothListByIdSafe("enemies", alpha);
    smoothListByIdSafe("hazards", alpha);
    smoothListByIdSafe("playerBullets", alpha);
    smoothListByIdSafe("enemyBullets", alpha);
    smoothListByIdSafe("absorbers", alpha);
  }

  function drawState(g, myUid) {
    clearFull();
    ui.hud.style.display = "";
    drawBackgroundForWave(g.wave || 1);

    if (Array.isArray(g.absorbers)) {
      for (const a of g.absorbers) {
        const s = toScreen(a.x, a.y);
        const t = (a.t ?? 0);
        const pulse = 0.5 + 0.5 * Math.sin(t * 4.0);
        const r = SIZE.absorberR * (0.85 + 0.15 * pulse);

        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#7bdff2";
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 0.95;
        ctx.strokeStyle = "rgba(123,223,242,.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.stroke();

        ctx.globalAlpha = 0.45;
        ctx.strokeStyle = "rgba(255,255,255,.45)";
        ctx.lineWidth = 1;
        for (let i=0;i<3;i++) {
          const rr = r * (0.45 + 0.18*i) + pulse*3;
          ctx.beginPath();
          ctx.arc(s.x, s.y, rr, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    const my = (g.players || []).find(p => p.uid === myUid);
    if (my) {
      ui.hudLine1.textContent = `YOU: BLUE | SCORE: ${my.score} | WAVE: ${g.wave}`;
      ui.hudLine2.textContent = `連射ON（Space押しっぱなしOK）`;
      ui.hudLine3.textContent = `A/D移動 Space連射 | 生存: ${my.alive ? "YES" : "NO"}`;
      ui.youTag.textContent = `YOU:BLUE`;
    } else {
      ui.hudLine1.textContent = `WAVE: ${g.wave} elapsed:${g.elapsed ?? "?"}`;
      ui.hudLine2.textContent = "";
      ui.hudLine3.textContent = "観戦中";
      ui.youTag.textContent = `YOU:WATCH`;
    }

    drawBossBar(g.boss);

    for (const e of (g.enemies || [])) {
      const s = toScreen(e.x, e.y);
      ctx.fillStyle =
        e.type === "A" ? "#ffd166" :
        e.type === "B" ? "#ff9f1c" :
        e.type === "C" ? "#7bdff2" :
        e.type === "E" ? "#b8f2a6" : "#ffd166";
      ctx.fillRect(s.x - SIZE.enemyS/2, s.y - SIZE.enemyS/2, SIZE.enemyS, SIZE.enemyS);
    }

    for (const hz of (g.hazards || [])) {
      const s = toScreen(hz.x, hz.y);
      ctx.fillStyle = hz.type === "BOMB" ? "#ff3b3b" : "#ff4d6d";
      ctx.beginPath();
      ctx.arc(s.x, s.y, SIZE.hazardR, 0, Math.PI * 2);
      ctx.fill();

      if (hz.type === "BOMB") {
        ctx.strokeStyle = "rgba(255,255,255,.8)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    if (g.boss && g.boss.alive) {
      const s = toScreen(g.boss.x, g.boss.y);
      ctx.fillStyle = g.boss.shieldLeft > 0 ? "#7bdff2" : "#ff3b3b";
      ctx.fillRect(s.x - SIZE.bossW/2, s.y - SIZE.bossH/2, SIZE.bossW, SIZE.bossH);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(s.x - SIZE.bossW/2, s.y - SIZE.bossH/2, SIZE.bossW, SIZE.bossH);
      ctx.lineWidth = 1;
    }

    for (const p of (g.players || [])) {
      const s = toScreen(p.x, p.y);
      const col = "#2b78ff";
      ctx.fillStyle = col;
      ctx.fillRect(s.x - SIZE.playerW/2, s.y - SIZE.playerH/2, SIZE.playerW, SIZE.playerH);
      if (p.uid === myUid) {
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x - SIZE.playerW/2 - 2, s.y - SIZE.playerH/2 - 2, SIZE.playerW + 4, SIZE.playerH + 4);
        ctx.lineWidth = 1;
      }
    }

    ctx.save();
    ctx.shadowColor = "rgba(255,255,255,.55)";
    ctx.shadowBlur = 10;
    ctx.fillStyle = "#ffffff";
    for (const b of (g.playerBullets || [])) {
      const s = toScreen(b.x, b.y);
      ctx.fillRect(s.x - SIZE.bulletW/2, s.y - SIZE.bulletH/2, SIZE.bulletW, SIZE.bulletH);
    }
    ctx.restore();

    for (const b of (g.enemyBullets || [])) {
      const s = toScreen(b.x, b.y);
      const col =
        b.type === "C_HOMING" ? "#7bdff2" :
        (b.type || "").includes("SNIPE") ? "#ffffff" :
        (b.type || "").includes("WAVE") ? "#b4f8c8" :
        (b.type || "").includes("SPLIT") ? "#ffd6ff" :
        (b.type || "").includes("LASER_WARN") ? "#ffd166" :
        (b.type || "").includes("LASER") ? "#ff3b3b" :
        "#ffccff";
      ctx.fillStyle = col;

      if ((b.type || "").includes("LASER")) {
        const w = 10;
        ctx.globalAlpha = (b.type || "").includes("WARN") ? 0.45 : 0.85;
        ctx.fillRect(s.x - w/2, 0, w, stageH);
        ctx.globalAlpha = 1;
      } else {
        ctx.fillRect(s.x - SIZE.eBulletS/2, s.y - SIZE.eBulletS/2, SIZE.eBulletS, SIZE.eBulletS);
      }
    }
  }

  function drawIdle(text) {
    clearFull();
    drawBackgroundForWave(1);
    ctx.fillStyle = "#9fb0cc";
    ctx.font = "16px system-ui";
    ctx.fillText(text, 16, 28);
    ui.hud.style.display = "none";
  }

  function hideWaveBanner() { ui.waveBanner.style.display = "none"; }

  function startRenderLoop() {
    function frame() {
      if (latestSnap && state.userId) {
        try {
          const w = latestSnap.wave ?? null;
          const t = latestSnap.tick ?? null;
          const s = latestSnap.sentAt ?? null;

          const waveChanged = (lastSeenWave != null && w != null && w !== lastSeenWave);
          const tickReset = (lastSeenTick != null && t != null && t < lastSeenTick);
          const sentAtJump = (lastSeenSentAt != null && s != null && Math.abs(s - lastSeenSentAt) > 4000);

          if (!renderState) {
            hardResetRenderStateFromLatest();
          } else if (waveChanged || tickReset || sentAtJump) {
            hardResetRenderStateFromLatest();
          } else {
            smoothToward(EMA_ALPHA);
            lastSeenWave = w;
            lastSeenTick = t;
            lastSeenSentAt = s;
          }

          if ((latestSnap?.waveDelayLeft ?? 0) > 0) {
            ui.waveBannerTitle.textContent = `WAVE ${latestSnap.wave}/4`;
            ui.waveBannerSub.textContent = `${Math.ceil(latestSnap.waveDelayLeft)}秒後に開始`;
            ui.waveBanner.style.display = "flex";
          } else {
            if (ui.waveBanner.style.display !== "none") hideWaveBanner();
          }

          drawState(renderState || latestSnap, state.userId);
        } catch (e) {
          console.error("render error", e);
          renderState = null;
        }
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  }

  const FIRE_RATE = 10;

  function bindInputSenderForRoom(userId, roomId, getIsPlayerFn) {
    const keys = { left:false, right:false, shoot:false };
    let bound = true;

    const down = (e) => {
      if (!bound) return;
      if (e.code === "KeyA") keys.left = true;
      if (e.code === "KeyD") keys.right = true;
      if (e.code === "Space") { keys.shoot = true; e.preventDefault(); }
    };
    const up = (e) => {
      if (!bound) return;
      if (e.code === "KeyA") keys.left = false;
      if (e.code === "KeyD") keys.right = false;
      if (e.code === "Space") { keys.shoot = false; e.preventDefault(); }
    };
    window.addEventListener("keydown", down);
    window.addEventListener("keyup", up);

    const timer = setInterval(() => {
      if (!bound) return;
      if (!roomId) return;
      if (!getIsPlayerFn()) return;
      set(ref(db, PATHS.roomInputs(roomId, userId)), { ...keys, t: Date.now() });
    }, 50);

    return () => {
      bound = false;
      clearInterval(timer);
      window.removeEventListener("keydown", down);
      window.removeEventListener("keyup", up);
    };
  }

  // ---------------- Game simulation (host) ----------------
  const WAVE_DUR = [30, 40, 90, 140];
  const SCORE = { A: 60, B: 120, C: 200, D: 0, E: 300, BOSS_HIT: 10, BOSS_KILL: 5000 };
  const ENEMY = {
    A: { firePerSec: 0.12, bulletSpeed: 0.28, moveSpeed: 0.06 },
    B: { firePerSec: 0.18, bulletSpeed: 0.32, moveSpeed: 0.09 },
    C: { firePerSec: 0.14, bulletSpeed: 0.26, moveSpeed: 0.06, homingTime: 0.7, turnRate: 2.2 },
    E: { firePerSec: 0.45, bulletSpeed: 0.36 },
    D: { fallSpeed: 0.10 }
  };
  const BOSS = {
    hpMax: 400,
    x: 0.5,
    y: 0.16,
    baseBulletSpeed: 0.33,
    shieldEvery: 2.0,
    shieldDuration: 1.8,
    moveSpeed: 0.22
  };
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const normalizeAngle=(a)=>{while(a>Math.PI)a-=Math.PI*2;while(a<-Math.PI)a+=Math.PI*2;return a;};
  const mulberry32=(a)=>()=>{let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;};
  const randChoice=(rng,arr)=>arr[Math.floor(rng()*arr.length)];
  const bossPhase = (b)=> b.hp>300?1:b.hp>200?2:b.hp>100?3:4;

  const WAVE_START_DELAY = 5.0;

  function createHostSim(room) {
    const p1Uid = room.p1Uid;
    const rng = mulberry32((Date.now() ^ 0x9e3779b9) >>> 0);

    const st = {
      tick: 0,
      mode: room.mode,
      elapsed: 0,
      wave: 1,

      waveDelayLeft: WAVE_START_DELAY,
      bossKilled: false,

      formation: { dir: 1, xOffset: 0, yOffset: 0, speedBase: 0.10, stepDown: 0.03 },

      players: {},
      enemies: [],
      hazards: [],
      absorbers: [],

      playerBullets: [],
      enemyBullets: [],
      boss: null,

      _hazAcc: 0,
      _eAcc: 0,
      _bossRespawnAcc: 0,
      _w2SpawnAcc: 0,
      _w2BombAcc: 0,
      _w3AbsAcc: 0,

      nextEnemyId: 1,
      nextHazardId: 1,
      nextAbsId: 1,
      nextPBulletId: 1,
      nextEBulletId: 1,

      rng
    };

    const DESPAWN_PAD = 0.18;
    function isOutNorm(x, y, pad = DESPAWN_PAD) {
      return (x < -pad || x > 1 + pad || y < -pad || y > 1 + pad);
    }
    function cleanupOutOfBounds() {
      st.enemies = (st.enemies || []).filter(e => e && e.alive !== false && !isOutNorm(e.x, e.y));
      st.hazards = (st.hazards || []).filter(h => h && h.alive !== false && !isOutNorm(h.x, h.y));
      st.absorbers = (st.absorbers || []).filter(a => a && a.alive !== false && !isOutNorm(a.x, a.y, 0.35));
      st.playerBullets = (st.playerBullets || []).filter(b => b && !b.dead && !isOutNorm(b.x, b.y));
      st.enemyBullets  = (st.enemyBullets  || []).filter(b => b && !b.dead && !isOutNorm(b.x, b.y, 0.35));
    }

    const mkPlayer = (playerUid, color, x) => ({ uid: playerUid, color, x, y: 0.9, alive: true, score: 0, fireAcc: 0 });
    st.players[p1Uid] = mkPlayer(p1Uid, "blue", 0.5);

    let lastInputs = {};
    const applyInputs = (inputs) => { lastInputs = inputs || {}; };

    function spawnFormation(types) {
      const rows=3, cols=6, x0=0.18, y0=0.14, dx=0.11, dy=0.085;
      for (let r=0;r<rows;r++) for (let c=0;c<cols;c++) {
        const type = randChoice(st.rng, types);
        st.enemies.push({ id:`en_${st.nextEnemyId++}`, type, baseX:x0+c*dx, baseY:y0+r*dy, x:x0+c*dx, y:y0+r*dy, alive:true, fireAcc:0 });
      }
    }

    function spawnBoss() {
      st.boss = {
        id: "boss",
        alive:true,
        x:BOSS.x, y:BOSS.y,
        hp:BOSS.hpMax, hpMax:BOSS.hpMax,
        time:0, attackAcc:0,
        shieldAcc:0, shieldLeft:0,
        feintQueue:[],
        dashLeft:0, dashDir:1,
      };
    }

    function resetWaveRuntimeAccumulators() {
      st._hazAcc = 0;
      st._eAcc = 0;
      st._w2SpawnAcc = 0;
      st._w2BombAcc = 0;
      st._w3AbsAcc = 0;
    }

    function spawnWave(w) {
      st.enemies = [];
      st.hazards = [];
      st.absorbers = [];
      st.enemyBullets = [];
      st.playerBullets = [];
      resetWaveRuntimeAccumulators();

      st.formation.dir = 1; st.formation.xOffset = 0; st.formation.yOffset = 0;
      st.boss = null;

      if (w===1) spawnFormation(["A"]);
      if (w===2) spawnFormation(["A","B","C"]);
      if (w===3) spawnFormation(["B","C"]);
      if (w===4) spawnBoss();

      st.waveDelayLeft = WAVE_START_DELAY;
      cleanupOutOfBounds();
    }
    spawnWave(1);

    function waveTimeBoundaries() {
      const t = st.elapsed;
      const tW1=WAVE_DUR[0], tW2=tW1+WAVE_DUR[1], tW3=tW2+WAVE_DUR[2];
      return { tW1, tW2, tW3, t };
    }

    function waveRemainingSeconds(w) {
      const { tW1, tW2, tW3, t } = waveTimeBoundaries();
      if (w === 1) return Math.max(0, tW1 - t);
      if (w === 2) return Math.max(0, tW2 - t);
      if (w === 3) return Math.max(0, tW3 - t);
      return 0;
    }

    function pickAlivePlayer() {
      const arr = Object.values(st.players).filter(p=>p.alive);
      if (!arr.length) return null;
      return arr[Math.floor(st.rng()*arr.length)];
    }

    function updateFormation(dt) {
      const fes = st.enemies.filter(e=>e.alive && (e.type==="A"||e.type==="B"||e.type==="C"));
      if (!fes.length) return;
      let minX=Infinity, maxX=-Infinity;
      for (const e of fes) { const x=e.baseX+st.formation.xOffset; minX=Math.min(minX,x); maxX=Math.max(maxX,x); }
      st.formation.xOffset += st.formation.dir * st.formation.speedBase * dt;
      if (maxX>0.92){ st.formation.dir=-1; st.formation.yOffset += st.formation.stepDown; }
      if (minX<0.08){ st.formation.dir= 1; st.formation.yOffset += st.formation.stepDown; }
      for (const e of fes) {
        const extra=(e.type==="B")?(ENEMY.B.moveSpeed-ENEMY.A.moveSpeed):0;
        e.x = e.baseX + st.formation.xOffset*(1+extra);
        e.y = e.baseY + st.formation.yOffset;
      }
    }

    function updateE(dt) {
      for (const e of st.enemies) {
        if (!e.alive || e.type!=="E") continue;
        e.t=(e.t??0)+dt;
        e.x = e.x0 + Math.sin(e.t*2.2)*0.10;
        e.y += 0.12*dt;
        if (e.y>1.1) e.alive=false;
      }
    }

    function updateHazards(dt) {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        h.y += ENEMY.D.fallSpeed*dt;
        if (h.y>1.1) h.alive=false;
      }
    }

    function updateAbsorbers(dt) {
      for (const a of st.absorbers) {
        if (!a.alive) continue;
        a.t = (a.t ?? 0) + dt;
        a.life = (a.life ?? 0) + dt;
        a.x = clamp(a.x + Math.sin(a.t*0.9)*0.004*dt, 0.12, 0.88);
        a.y = clamp(a.y + Math.sin(a.t*1.1)*0.003*dt, 0.12, 0.78);
        if (a.life > (a.lifeMax ?? 8.0)) a.alive = false;
      }
      st.absorbers = st.absorbers.filter(a => a.alive);
    }

    function absorbPlayerBullets() {
      if (!st.absorbers.length || !st.playerBullets.length) return;
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        for (const a of st.absorbers) {
          if (!a.alive) continue;
          const dx = a.x - b.x, dy = a.y - b.y;
          const r = (a.r ?? 0.06);
          if (dx*dx + dy*dy <= r*r) { b.dead = true; break; }
        }
      }
    }

    function spawnHazardsWave3(dt) {
      if (st.wave!==3) return;
      st._hazAcc += dt/8;
      if (st._hazAcc<1) return;
      st._hazAcc -= 1;
      st.hazards.push({ id:`hz_${st.nextHazardId++}`, type:"D", x:0.10+st.rng()*0.80, y:-0.05, alive:true });
    }

    function spawnEIfNeeded(dt) {
      if (st.wave!==3) return;
      st._eAcc += dt/5;
      if (st._eAcc<1) return;
      st._eAcc -= 1;
      const x0=0.15+st.rng()*0.70;
      st.enemies.push({ id:`en_${st.nextEnemyId++}`, type:"E", x0, x:x0, y:-0.06, t:0, alive:true, fireAcc:0 });
    }

    function spawnWave2Random(dt) {
      if (st.wave !== 2) return;
      st._w2SpawnAcc += dt / (0.75 + st.rng()*0.55);
      if (st._w2SpawnAcc < 1) return;
      st._w2SpawnAcc -= 1;

      const type = randChoice(st.rng, ["A","B","B","C","A","C"]);
      const x0 = 0.10 + st.rng()*0.80;
      const y0 = -0.06 - st.rng()*0.06;
      st.enemies.push({ id:`en_${st.nextEnemyId++}`, type, x0, x:x0, y:y0, t:0, alive:true, fireAcc:0, w2Solo:true });
    }

    function updateWave2SoloEnemies(dt) {
      if (st.wave !== 2) return;
      for (const e of st.enemies) {
        if (!e.alive || !e.w2Solo) continue;
        e.t = (e.t ?? 0) + dt;
        e.x = e.x0 + Math.sin(e.t*1.6) * 0.08;
        e.y += 0.08*dt;
        if (e.y > 1.15) e.alive = false;
      }
    }

    function spawnBombsWave2(dt) {
      if (st.wave !== 2) return;
      st._w2BombAcc += dt / (0.85 + st.rng()*0.85);
      if (st._w2BombAcc < 1) return;
      st._w2BombAcc -= 1;
      st.hazards.push({ id:`hz_${st.nextHazardId++}`, type:"BOMB", x:0.08 + st.rng()*0.84, y:-0.08, alive:true });
    }

    function movePlayerBullets(dt) {
      for (const b of st.playerBullets) b.y -= 0.85*dt;
      st.playerBullets = st.playerBullets.filter(b=>b.y>-0.1 && !b.dead);
    }

    function moveEnemyBullets(dt) {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;

        if ((b.type || "").includes("LASER_WARN")) {
          b.life = (b.life ?? 0) + dt;
          if (b.life >= (b.warnFor ?? 0.7)) {
            b.type = "BOSS_LASER";
            b.life = 0;
            b.laserFor = b.laserFor ?? 0.35;
          }
          continue;
        }

        if ((b.type || "").includes("BOSS_LASER")) {
          b.life = (b.life ?? 0) + dt;
          if (b.life >= (b.laserFor ?? 0.35)) b.dead = true;
          continue;
        }

        if (b.waveAmp) {
          b.waveT=(b.waveT??0)+dt;
          b.x += Math.sin(b.waveT*b.waveFreq)*b.waveAmp*dt;
        }
        if (b.splitAt!=null) {
          b.life=(b.life??0)+dt;
          if (!b.splitDone && b.life>=b.splitAt) {
            b.splitDone=true;
            const spd=Math.hypot(b.vx,b.vy);
            st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:b.x, y:b.y, vx:-0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:b.x, y:b.y, vx: 0.18, vy:spd, type:"SPLIT_CHILD", dead:false });
            b.dead=true; continue;
          }
        }
        if (b.type==="C_HOMING" && b.homingLeft>0) {
          b.homingLeft-=dt;
          const t = pickAlivePlayer();
          if (t) {
            const dx=t.x-b.x, dy=t.y-b.y;
            const desired=Math.atan2(dy,dx);
            const cur=Math.atan2(b.vy,b.vx);
            const diff=normalizeAngle(desired-cur);
            const maxTurn=(b.turnRate ?? 2.2)*dt;
            const turned=cur+Math.max(-maxTurn, Math.min(maxTurn, diff));
            const spd=Math.hypot(b.vx,b.vy);
            b.vx=Math.cos(turned)*spd;
            b.vy=Math.sin(turned)*spd;
          }
        }
        b.x += b.vx*dt;
        b.y += b.vy*dt;
        if (b.y>1.2 || b.x<-0.2 || b.x>1.2 || b.y<-0.35) b.dead=true;
      }
      st.enemyBullets = st.enemyBullets.filter(b=>!b.dead);
    }

    function enemyFire(dt) {
      const alivePlayers = Object.values(st.players).filter(p=>p.alive);
      if (!alivePlayers.length) return;
      for (const e of st.enemies) {
        if (!e.alive) continue;
        if (!(e.type==="A"||e.type==="B"||e.type==="C"||e.type==="E")) continue;
        const cfg = ENEMY[e.type];
        const mult = (st.wave===2 && (e.type==="B"||e.type==="C")) ? 3 : 1;

        e.fireAcc=(e.fireAcc??0)+(cfg.firePerSec*mult)*dt;
        while (e.fireAcc>=1) {
          e.fireAcc-=1;
          if (e.type==="C") {
            const t=pickAlivePlayer(); if(!t) break;
            const dx=t.x-e.x, dy=t.y-e.y;
            const ang=Math.atan2(dy,dx);
            const spd=cfg.bulletSpeed;
            st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:e.x,y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, type:"C_HOMING", homingLeft:cfg.homingTime, turnRate: cfg.turnRate, dead:false });
          } else {
            const t=pickAlivePlayer();
            const aim=t?Math.max(-0.25, Math.min(0.25, (t.x-e.x)*1.2)):0;
            st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:e.x,y:e.y, vx:aim, vy:cfg.bulletSpeed, type:`${e.type}_SHOT`, dead:false });
          }
        }
      }
    }

    function collidePlayerBulletsToEnemies() {
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        for (const e of st.enemies) {
          if (!e.alive) continue;
          const dx=e.x-b.x, dy=e.y-b.y;
          if (dx*dx+dy*dy<0.00085) {
            e.alive=false; b.dead=true;
            const p=st.players[b.ownerUid]; if (p) p.score += (SCORE[e.type]??0);
            break;
          }
        }
      }
      st.enemies = st.enemies.filter(e=>e.alive);
    }

    function collideHazardsToPlayers() {
      for (const h of st.hazards) {
        if (!h.alive) continue;
        for (const puid in st.players) {
          const p=st.players[puid]; if(!p.alive) continue;
          const dx=p.x-h.x, dy=p.y-h.y;
          if (dx*dx+dy*dy<0.0016) { p.alive=false; h.alive=false; break; }
        }
      }
      st.hazards = st.hazards.filter(h=>h.alive);
    }

    function collideEnemyBulletsToPlayers() {
      for (const b of st.enemyBullets) {
        if (b.dead) continue;

        if ((b.type || "").includes("BOSS_LASER")) {
          for (const puid in st.players) {
            const p=st.players[puid]; if(!p.alive) continue;
            const dx = Math.abs((p.x ?? 0) - (b.x ?? 0));
            if (dx < 0.03) p.alive=false;
          }
          continue;
        }

        for (const puid in st.players) {
          const p=st.players[puid]; if(!p.alive) continue;
          const dx=p.x-b.x, dy=p.y-b.y;
          if (dx*dx+dy*dy<0.0010) { p.alive=false; b.dead=true; break; }
        }
      }
    }

    function doBossAttack(phase, enrage) {
      const patterns = [pRing, pRightSide, pLaserWall];
      if (phase>=2) patterns.push(pSnipe, pSplit);
      if (phase>=3) patterns.push(pWave, pHomingWeak, pFeint);
      if (phase>=4) patterns.push(pDash, pSnake, pCone);
      const p = randChoice(st.rng, patterns);
      p(enrage);
    }

    function pRing(enrage) {
      const boss=st.boss;
      const phase=bossPhase(boss);
      const n = phase===1?12:phase===2?16:phase===3?18:22;
      const spd=BOSS.baseBulletSpeed*(1+0.10*(phase-1))*enrage;
      for (let i=0;i<n;i++){
        const a=Math.PI*2*(i/n);
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_RING", dead:false });
      }
    }
    function pRightSide(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.15*enrage;
      const n=10;
      for (let i=0;i<n;i++){
        const a=(-Math.PI/2)+(i/(n-1))*(Math.PI/2);
        const vx=Math.cos(a)*spd+0.20;
        const vy=Math.sin(a)*spd+0.55;
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx,vy, type:"BOSS_RIGHT", dead:false });
      }
    }
    function pWave(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*enrage;
      const n=7;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.03;
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.24, waveFreq:7.5, type:"BOSS_WAVE", dead:false });
      }
    }
    function pFeint(enrage) {
      const boss=st.boss;
      const delay=0.45+(st.rng()*0.35);
      boss.feintQueue.push({
        t: delay,
        pattern: () => {
          const spd=BOSS.baseBulletSpeed*1.05*enrage;
          const n=10;
          for (let i=0;i<n;i++){
            const a=Math.PI*2*(i/n);
            st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_FEINT", dead:false });
          }
        }
      });
    }
    function pSnipe(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      boss.feintQueue.push({
        t: 0.55,
        pattern: () => {
          const dx=target.x-boss.x, dy=target.y-boss.y;
          const a=Math.atan2(dy,dx);
          const spd=BOSS.baseBulletSpeed*2.2*enrage;
          st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_SNIPE", dead:false });
        }
      });
    }
    function pSplit(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.25*enrage;
      st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:0, vy:spd, splitAt:0.55, splitDone:false, type:"BOSS_SPLIT", dead:false });
    }
    function pHomingWeak(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer(); if(!target) return;
      const dx=target.x-boss.x, dy=target.y-boss.y;
      const a=Math.atan2(dy,dx);
      const spd=BOSS.baseBulletSpeed*1.15*enrage;
      st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"C_HOMING", homingLeft:0.9, turnRate: 2.8, dead:false });
    }
    function pDash(enrage) {
      const boss=st.boss;
      boss.dashLeft = 0.9*Math.min(1.5,enrage);
      boss.dashDir = (st.rng()<0.5) ? -1 : 1;
    }
    function pSnake(enrage) {
      const boss=st.boss;
      const spd=BOSS.baseBulletSpeed*1.05*enrage;
      const n=5;
      for (let i=0;i<n;i++){
        const xoff=(i-(n-1)/2)*0.05;
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x+xoff,y:boss.y, vx:0, vy:spd, waveAmp:0.32, waveFreq:9.8, type:"BOSS_SNAKE", dead:false });
      }
    }

    function pLaserWall(enrage) {
      const boss = st.boss;
      const n = 3 + (bossPhase(boss) >= 3 ? 1 : 0);
      for (let i=0;i<n;i++) {
        const x = 0.18 + st.rng()*0.64;
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x, y: 0.0, type:"BOSS_LASER_WARN", warnFor: 0.7 / Math.min(1.4, enrage), laserFor: 0.35 + 0.10*st.rng(), dead:false });
      }
    }

    function pCone(enrage) {
      const boss=st.boss;
      const target=pickAlivePlayer();
      const baseA = target ? Math.atan2(target.y-boss.y, target.x-boss.x) : Math.PI/2;
      const spread = Math.PI/2.6;
      const n = 16;
      const spd = BOSS.baseBulletSpeed * 1.05 * enrage;
      for (let i=0;i<n;i++){
        const tt = (i/(n-1))*2-1;
        const a = baseA + tt*spread;
        st.enemyBullets.push({ id:`eb_${st.nextEBulletId++}`, x:boss.x,y:boss.y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, type:"BOSS_CONE", dead:false });
      }
    }

    function updateBoss(dt, wave4Elapsed) {
      const boss = st.boss;
      if (!boss || !boss.alive) return;

      boss.time += dt;
      const over = Math.max(0, wave4Elapsed - WAVE_DUR[3]);
      const enrage = 1 + over * 0.015;

      if (boss.dashLeft>0) {
        boss.dashLeft -= dt;
        boss.x += boss.dashDir*(BOSS.moveSpeed*3.3)*dt;
        boss.y += 0.22*dt;
        if (boss.x<0.10){ boss.x=0.10; boss.dashDir=1; }
        if (boss.x>0.90){ boss.x=0.90; boss.dashDir=-1; }
      } else {
        boss.x += Math.sin(boss.time*1.2)*0.085*dt;
        boss.y += Math.sin(boss.time*0.9)*0.04*dt;
      }
      boss.x = clamp(boss.x,0.10,0.90);
      boss.y = clamp(boss.y,0.12,0.32);

      boss.shieldAcc += dt;
      if (boss.shieldLeft>0) boss.shieldLeft -= dt;
      if (boss.shieldAcc >= BOSS.shieldEvery) {
        boss.shieldAcc = 0;
        boss.shieldLeft = BOSS.shieldDuration;
      }

      for (const f of boss.feintQueue) f.t -= dt;
      while (boss.feintQueue.length && boss.feintQueue[0].t <= 0) {
        const fire = boss.feintQueue.shift();
        if (fire) fire.pattern();
      }

      const phase = bossPhase(boss);
      const baseAttacksPerSec = phase===1?0.85:phase===2?1.05:phase===3?1.25:1.55;
      boss.attackAcc += baseAttacksPerSec * Math.min(2.4,enrage) * dt;
      while (boss.attackAcc >= 1) { boss.attackAcc -= 1; doBossAttack(phase, Math.min(2.4,enrage)); }
    }

    function collidePlayerBulletsToBoss() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const b of st.playerBullets) {
        if (b.dead) continue;
        const dx=boss.x-b.x, dy=boss.y-b.y;
        if (dx*dx+dy*dy<0.0032) {
          b.dead = true;
          if (boss.shieldLeft>0) continue;
          boss.hp -= 1;
          const p=st.players[b.ownerUid]; if (p) p.score += SCORE.BOSS_HIT;
          if (boss.hp<=0) {
            boss.alive = false;
            st.bossKilled = true;
            const pl = st.players[b.ownerUid]; if (pl) pl.score += SCORE.BOSS_KILL;
          }
        }
      }
    }

    function collideBossToPlayers() {
      const boss=st.boss;
      if (!boss || !boss.alive) return;
      for (const puid in st.players) {
        const p=st.players[puid]; if(!p.alive) continue;
        const dx=p.x-boss.x, dy=p.y-boss.y;
        if (dx*dx+dy*dy<0.0040) p.alive=false;
      }
    }

    function isAllDead() { return Object.values(st.players).every(p=>!p.alive); }

    function isWaveClearedForRespawn() {
      if (st.wave > 3) return false;
      if (st.waveDelayLeft > 0) return false;
      const aliveEnemies = st.enemies.some(e => e.alive);
      const aliveHaz = st.hazards.some(h => h.alive);
      const anyEnemyBullets = st.enemyBullets.some(b => !b.dead);
      return !aliveEnemies && !aliveHaz && !anyEnemyBullets && (waveRemainingSeconds(st.wave) > 3.0);
    }

    function respawnNonBossForWave(w) {
      st.enemies = [];
      st.hazards = [];
      st.enemyBullets = [];
      if (w === 1) spawnFormation(["A"]);
      if (w === 2) spawnFormation(["A","B","C"]);
      if (w === 3) spawnFormation(["B","C"]);
      cleanupOutOfBounds();
    }

    function step(dt) {
      st.tick++;

      if (st.waveDelayLeft > 0) {
        st.waveDelayLeft = Math.max(0, st.waveDelayLeft - dt);
        return;
      }

      st.elapsed += dt;

      const t = st.elapsed;
      const tW1=WAVE_DUR[0], tW2=tW1+WAVE_DUR[1], tW3=tW2+WAVE_DUR[2];
      let newWave = st.wave;
      if (t < tW1) newWave=1;
      else if (t < tW2) newWave=2;
      else if (t < tW3) newWave=3;
      else newWave=4;

      if (newWave !== st.wave) { st.wave = newWave; spawnWave(newWave); return; }

      for (const puid in st.players) {
        const p=st.players[puid];
        if (!p.alive) continue;
        const inp = lastInputs?.[puid] || {};
        const speed=0.45;
        if (inp.left) p.x -= speed*dt;
        if (inp.right) p.x += speed*dt;
        p.x = clamp(p.x, 0.05, 0.95);

        if (inp.shoot) {
          p.fireAcc += FIRE_RATE * dt;
          while (p.fireAcc >= 1) {
            p.fireAcc -= 1;
            st.playerBullets.push({ id:`pb_${st.nextPBulletId++}`, x:p.x, y:p.y-0.03, ownerUid:puid, dead:false });
          }
        } else {
          p.fireAcc = 0;
        }
      }

      if (st.wave === 1) {
        updateFormation(dt);
        enemyFire(dt);
        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collidePlayerBulletsToEnemies();

        movePlayerBullets(dt);
        st.playerBullets = st.playerBullets.filter(b=>!b.dead);
      }

      if (st.wave === 2) {
        spawnWave2Random(dt);
        spawnBombsWave2(dt);

        updateFormation(dt);
        updateWave2SoloEnemies(dt);
        updateHazards(dt);

        enemyFire(dt);
        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideHazardsToPlayers();
        collidePlayerBulletsToEnemies();

        movePlayerBullets(dt);
        st.playerBullets = st.playerBullets.filter(b=>!b.dead);
      }

      if (st.wave === 3) {
        updateFormation(dt);
        updateE(dt);
        updateHazards(dt);

        st._w3AbsAcc += dt / (2.2 + st.rng()*1.1);
        if (st._w3AbsAcc >= 1) {
          st._w3AbsAcc -= 1;
          st.absorbers.push({ id:`ab_${st.nextAbsId++}`, x: 0.14 + st.rng()*0.72, y: 0.18 + st.rng()*0.45, r: 0.07, alive: true, life: 0, lifeMax: 9.0, t: 0 });
        }
        updateAbsorbers(dt);

        enemyFire(dt);
        spawnHazardsWave3(dt);
        spawnEIfNeeded(dt);

        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideHazardsToPlayers();

        movePlayerBullets(dt);
        absorbPlayerBullets();
        st.playerBullets = st.playerBullets.filter(b=>!b.dead);

        collidePlayerBulletsToEnemies();
      }

      if (st.wave === 4) {
        const wave4Elapsed = Math.max(0, st.elapsed - tW3);
        if ((!st.boss || !st.boss.alive) && !isAllDead() && !st.bossKilled) {
          st._bossRespawnAcc += dt;
          if (st._bossRespawnAcc >= 3.0) { st._bossRespawnAcc = 0; spawnBoss(); }
        } else {
          st._bossRespawnAcc = 0;
        }

        updateBoss(dt, wave4Elapsed);
        moveEnemyBullets(dt);
        collideEnemyBulletsToPlayers();
        collideBossToPlayers();

        movePlayerBullets(dt);
        st.playerBullets = st.playerBullets.filter(b=>!b.dead);

        collidePlayerBulletsToBoss();
      }

      if (st.wave !== 3) st.absorbers = [];

      if (isWaveClearedForRespawn()) respawnNonBossForWave(st.wave);

      cleanupOutOfBounds();
    }

    function snapshot() {
      const playersArr = Object.values(st.players).map(p=>({ uid:p.uid, x:p.x, y:p.y, alive:p.alive, score:p.score, color:p.color }));
      const boss = st.boss ? ({
        id: st.boss.id,
        x:st.boss.x, y:st.boss.y, alive:st.boss.alive,
        hp:st.boss.hp, hpMax:st.boss.hpMax,
        shieldLeft:st.boss.shieldLeft,
        phase: bossPhase(st.boss),
      }) : null;

      return {
        tick: st.tick,
        mode: st.mode,
        wave: st.wave,
        waveDelayLeft: st.waveDelayLeft,
        bossKilled: st.bossKilled,
        elapsed: Math.floor(st.elapsed*1000)/1000,
        players: playersArr,
        enemies: st.enemies.filter(e=>e.alive).map(e=>({ id:e.id, x:e.x,y:e.y,type:e.type })),
        hazards: st.hazards.filter(h=>h.alive).map(h=>({ id:h.id, x:h.x,y:h.y,type:h.type })),
        absorbers: st.absorbers.filter(a=>a.alive).map(a=>({ id:a.id, x:a.x,y:a.y,t:a.t??0 })),
        playerBullets: st.playerBullets.filter(b=>!b.dead).map(b=>({ id:b.id, x:b.x,y:b.y,ownerUid:b.ownerUid })),
        enemyBullets: st.enemyBullets.filter(b=>!b.dead).map(b=>({ id:b.id, x:b.x,y:b.y,type:b.type })),
        boss,
        sentAt: Date.now()
      };
    }

    return { step, snapshot, applyInputs, isAllDead };
  }

  const MAX_ROOMS = 5;
  const ROOM_MAX_PLAY_MS = 7 * 60 * 1000;

  const state = {
    userId: null,
    userName: "",
    roomId: null,
    roomUnsub: null,
    gameUnsub: null,
    stopInput: null,
    lastRoom: null,
  };

  async function countRooms() {
    const snap = await get(ref(db, PATHS.roomsIndex));
    const v = snap.val() || {};
    return Object.keys(v).length;
  }

  function isPlayer(room) { return room?.p1Uid === state.userId; }

  async function deleteRoom(roomId) {
    await remove(ref(db, PATHS.room(roomId)));
    await remove(ref(db, PATHS.roomIndex(roomId)));
  }

  async function leaveRoom(goLobby = true) {
    if (state.stopInput) { state.stopInput(); state.stopInput = null; }
    if (state.roomUnsub) { state.roomUnsub(); state.roomUnsub = null; }
    if (state.gameUnsub) { state.gameUnsub(); state.gameUnsub = null; }

    state.roomId = null;
    ui.roomTag.style.display = "none";
    ui.roomTag.textContent = "room:-";
    ui.readyBtn.style.display = "none";
    ui.retireBtn.style.display = "none";

    latestSnap = null;
    renderState = null;
    lastSeenWave = null;
    lastSeenTick = null;
    lastSeenSentAt = null;
    hideWaveBanner();

    if (goLobby) setScreen("lobby");
  }

  async function enterRoom(roomId) {
    await leaveRoom(false);

    state.roomId = roomId;
    ui.roomTag.style.display = "";
    ui.roomTag.textContent = `room:${roomId.slice(-6)}`;
    setScreen("game");

    state.stopInput = bindInputSenderForRoom(state.userId, roomId, () => {
      const room = state.lastRoom;
      return room?.state === "playing" && isPlayer(room);
    });

    subscribeRoom(roomId);
  }

  async function createRoom() {
    const roomsCount = await countRooms();
    if (roomsCount >= MAX_ROOMS) {
      ui.createHint.textContent = "部屋数が上限（5）です。誰かが部屋を削除してから作成してください。";
      return;
    }

    const roomId = `room_${Date.now()}_${uuidShort()}`;
    const now = Date.now();
    const room = {
      roomId,
      state: "preparing",
      mode: "solo",
      hostUid: state.userId,
      hostName: state.userName,
      p1Uid: state.userId,
      p2Uid: null,
      ready: { [state.userId]: false },
      createdAt: now,
      updatedAt: now,
      startedAt: 0
    };

    await set(ref(db, PATHS.room(roomId)), room);
    await set(ref(db, PATHS.roomIndex(roomId)), { roomId, state: room.state, mode: room.mode, hostName: state.userName, createdAt: now, startedAt: 0 });

    await enterRoom(roomId);
  }

  function stateDotClass(st) {
    if (st === "playing") return "playing";
    if (st === "preparing") return "preparing";
    if (st === "finished") return "finished";
    return "";
  }
  function roomStateLabel(st) {
    if (st === "preparing") return "準備中";
    if (st === "playing") return "プレイ中";
    if (st === "finished") return "終了";
    return "待機";
  }

  function bindRoomsList() {
    onValue(ref(db, PATHS.roomsIndex), (snap) => {
      const rooms = snap.val() || {};
      const entries = Object.values(rooms).sort((a,b) => (b.createdAt||0)-(a.createdAt||0));

      ui.roomsList.innerHTML = "";
      if (entries.length === 0) {
        ui.roomsList.innerHTML = `<div class="muted">部屋がありません。左から作成してください。</div>`;
        return;
      }

      for (const r of entries) {
        if (r.mode && r.mode !== "solo") continue;

        const div = document.createElement("div");
        div.className = "roomRow";

        const left = document.createElement("div");
        const top = document.createElement("div");
        top.className = "roomTop";
        top.innerHTML = `
          <span class="pill"><span class="dot ${stateDotClass(r.state)}"></span>${roomStateLabel(r.state || "idle")}</span>
          <span class="tag">#${r.roomId.slice(-6)}</span>
          <span class="tag">solo</span>
          <span class="muted">host: ${escapeHtml(r.hostName || "?")}</span>
        `;
        const meta = document.createElement("div");
        meta.className = "roomMeta";
        const sa = r.startedAt ? ` / started: ${new Date(r.startedAt).toLocaleTimeString()}` : "";
        meta.textContent = `created: ${new Date(r.createdAt || Date.now()).toLocaleTimeString()}${sa}`;
        left.appendChild(top);
        left.appendChild(meta);

        const btns = document.createElement("div");
        btns.className = "roomBtns";

        const joinBtn = document.createElement("button");
        joinBtn.className = "secondary small";
        joinBtn.textContent = "入室";
        joinBtn.onclick = async () => { await enterRoom(r.roomId); };
        btns.appendChild(joinBtn);

        if (adminMode) {
          const adminKill = document.createElement("button");
          adminKill.className = "danger small";
          adminKill.textContent = "運営:強制終了";
          adminKill.onclick = async () => {
            await update(ref(db, PATHS.room(r.roomId)), { state: "finished", finishedReason: "admin_kill", updatedAt: Date.now() }).catch(()=>{});
            await update(ref(db, PATHS.roomIndex(r.roomId)), { state: "finished" }).catch(()=>{});
          };

          const adminDel = document.createElement("button");
          adminDel.className = "danger small";
          adminDel.textContent = "運営:削除";
          adminDel.onclick = async () => { await deleteRoom(r.roomId); };

          btns.appendChild(adminKill);
          btns.appendChild(adminDel);
        }

        div.appendChild(left);
        div.appendChild(btns);
        ui.roomsList.appendChild(div);
      }
    });
  }

  const activeHostLoops = new Map();
  const hostStartLocks = new Map();

  function subscribeRoom(roomId) {
    const roomRef = ref(db, PATHS.room(roomId));
    const gameRef = ref(db, PATHS.roomGame(roomId));

    if (state.roomUnsub) state.roomUnsub();
    if (state.gameUnsub) state.gameUnsub();

    state.roomUnsub = onValue(roomRef, async (snap) => {
      const room = snap.val();
      state.lastRoom = room;

      if (!room) {
        latestSnap = null; renderState = null;
        drawIdle("部屋が削除されました");
        await leaveRoom(true);
        return;
      }

      ui.modeTag.textContent = `mode:${room.mode}`;
      ui.stateTag.textContent = `state:${room.state}`;
      ui.statusLine.textContent = `in ${roomId.slice(-6)} ${room.state}`;

      const player = isPlayer(room);
      const host = room.hostUid === state.userId;
      ui.retireBtn.style.display = (host && room.state === "playing") ? "" : "none";
      ui.readyBtn.style.display = (player && room.state === "preparing") ? "" : "none";

      const hostOn = await isOnline(room.hostUid);
      const p1On = await isOnline(room.p1Uid);
      if (!(hostOn || p1On)) await deleteRoom(roomId);

      await startHostLoopIfNeeded(roomId, room);

      if (room.state === "finished") {
        showAnn("ゲーム終了", `理由: ${room.finishedReason || "?"}\n部屋を閉じます…`);
        setTimeout(async () => {
          await deleteRoom(roomId);
          hideAnn();
          await leaveRoom(true);
        }, 1200);
      }
    });

    state.gameUnsub = onValue(gameRef, (snap) => {
      const g = snap.val() || null;
      latestSnap = g;

      if (!g) {
        drawIdle("準備中 / 観戦待機中");
        renderState = null;
        lastSeenWave = null;
        lastSeenTick = null;
        lastSeenSentAt = null;
        hideWaveBanner();
        return;
      }

      if (!renderState) hardResetRenderStateFromLatest();
    });
  }

  async function startHostLoopIfNeeded(roomId, room) {
    const isHost = room.hostUid === state.userId;
    const isPlaying = room.state === "playing";

    const existing = activeHostLoops.get(roomId);
    if (existing) {
      if (!isHost || !isPlaying) {
        clearInterval(existing);
        activeHostLoops.delete(roomId);
      }
      return;
    }

    if (hostStartLocks.get(roomId)) return;
    if (!isHost || !isPlaying) return;

    hostStartLocks.set(roomId, true);
    try {
      const sim = createHostSim(room);
      await set(ref(db, PATHS.roomGame(roomId)), sim.snapshot());

      const hz = 15;
      const intervalMs = Math.floor(1000 / hz);

      const timer = setInterval(async () => {
        const roomNow = (await get(ref(db, PATHS.room(roomId)))).val();
        if (!roomNow) { clearInterval(timer); activeHostLoops.delete(roomId); return; }
        if (roomNow.state !== "playing") return;

        const inputs = (await get(ref(db, PATHS.roomInputsRoot(roomId)))).val() || {};
        sim.applyInputs(inputs);
        sim.step(intervalMs / 1000);

        const snapGame = sim.snapshot();

        if (snapGame.bossKilled) {
          await set(ref(db, PATHS.roomGame(roomId)), snapGame);
          await update(ref(db, PATHS.room(roomId)), { state: "finished", finishedReason: "boss_killed", updatedAt: Date.now() });
          await update(ref(db, PATHS.roomIndex(roomId)), { state: "finished" });
          return;
        }

        if (sim.isAllDead()) {
          await set(ref(db, PATHS.roomGame(roomId)), snapGame);
          await update(ref(db, PATHS.room(roomId)), { state: "finished", finishedReason: "all_dead", updatedAt: Date.now() });
          await update(ref(db, PATHS.roomIndex(roomId)), { state: "finished" });
          return;
        }

        await set(ref(db, PATHS.roomGame(roomId)), snapGame);
      }, intervalMs);

      activeHostLoops.set(roomId, timer);
    } finally {
      hostStartLocks.delete(roomId);
    }
  }

  await signInAnonymously(auth);

  onAuthStateChanged(auth, async (user) => {
    if (!user) return;

    state.userId = user.uid;
    ui.me.textContent = `uid: ${state.userId.slice(0, 8)}…`;

    await bindPresence(state.userId);
    bindLeaderboard();
    bindRoomsList();
    startRenderLoop();

    state.userName = await getMyName(state.userId);
    if (!state.userName) {
      setScreen("name");
      ui.nameHint.textContent = "名前を入力して決定してください";
    } else {
      ui.myNameLabel.textContent = `名前: ${state.userName}`;
      setScreen("lobby");
    }

    ui.saveNameBtn.onclick = async () => {
      const v = ui.nameInput.value.trim().slice(0, 20);
      if (!v) { ui.nameHint.textContent = "名前を入力してください"; return; }
      await setMyName(state.userId, v);
      state.userName = v;
      ui.myNameLabel.textContent = `名前: ${state.userName}`;
      setScreen("lobby");
    };

    ui.changeNameBtn.onclick = () => { setScreen("name"); ui.nameHint.textContent = "名前を変更して決定してください"; };

    ui.createSoloBtn.onclick = async () => { if (!state.userName) return alert("名前を先に決定してください"); await createRoom(); };

    ui.leaveRoomBtn.onclick = async () => { await leaveRoom(true); };

    ui.readyBtn.onclick = async () => {
      if (!state.roomId) return;
      await set(ref(db, PATHS.roomReady(state.roomId, state.userId)), true);

      const roomRef = ref(db, PATHS.room(state.roomId));
      const room = (await get(roomRef)).val();
      if (!room || room.hostUid !== state.userId) return;
      if (room.state !== "preparing") return;

      const ready = room.ready || {};
      const ok1 = !!ready?.[room.p1Uid];

      if (ok1) {
        const now = Date.now();
        await update(roomRef, { state: "playing", startedAt: now, updatedAt: now });
        await update(ref(db, PATHS.roomIndex(state.roomId)), { state: "playing", startedAt: now });
      }
    };

    ui.retireBtn.onclick = async () => {
      if (!state.roomId) return;
      const roomRef = ref(db, PATHS.room(state.roomId));
      const room = (await get(roomRef)).val();
      if (!room || room.hostUid !== state.userId) return;
      await update(roomRef, { state: "finished", finishedReason: "retire", updatedAt: Date.now() });
      await update(ref(db, PATHS.roomIndex(state.roomId)), { state: "finished" });
    };
  });

  async function createRoom() {
    const roomsCount = await countRooms();
    if (roomsCount >= MAX_ROOMS) {
      ui.createHint.textContent = "部屋数が上限（5）です。誰かが部屋を削除してから作成してください。";
      return;
    }

    const roomId = `room_${Date.now()}_${uuidShort()}`;
    const now = Date.now();
    const room = {
      roomId,
      state: "preparing",
      mode: "solo",
      hostUid: state.userId,
      hostName: state.userName,
      p1Uid: state.userId,
      p2Uid: null,
      ready: { [state.userId]: false },
      createdAt: now,
      updatedAt: now,
      startedAt: 0
    };

    await set(ref(db, PATHS.room(roomId)), room);
    await set(ref(db, PATHS.roomIndex(roomId)), { roomId, state: room.state, mode: room.mode, hostName: state.userName, createdAt: now, startedAt: 0 });

    await enterRoom(roomId);
  }
</script>
</body>
</html>
